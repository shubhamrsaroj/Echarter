{
  "version": 3,
  "sources": ["../../node_modules/@azure/core-util/node_modules/@azure/abort-controller/src/AbortError.ts", "../../node_modules/@azure/core-util/node_modules/@azure/abort-controller/src/index.ts", "../../node_modules/@azure/core-util/src/createAbortablePromise.ts", "../../node_modules/@azure/core-util/src/random.ts", "../../node_modules/@azure/core-util/src/delay.ts", "../../node_modules/@azure/core-util/src/aborterUtils.ts", "../../node_modules/@azure/core-util/src/object.ts", "../../node_modules/@azure/core-util/src/error.ts", "../../node_modules/@azure/core-util/src/bytesEncoding.common.ts", "../../node_modules/@azure/core-util/src/bytesEncoding-browser.mts", "../../node_modules/@azure/core-util/src/sha256.common.ts", "../../node_modules/@azure/core-util/src/sha256-browser.mts", "../../node_modules/@azure/core-util/src/typeGuards.ts", "../../node_modules/@azure/core-util/src/uuidUtils.common.ts", "../../node_modules/@azure/core-util/src/uuidUtils-browser.mts", "../../node_modules/@azure/core-util/src/checkEnvironment.ts", "../../node_modules/@azure/core-util/src/index.ts", "../../node_modules/@azure/core-rest-pipeline/src/pipeline.ts", "../../node_modules/@azure/core-rest-pipeline/src/log.ts", "../../node_modules/@azure/core-rest-pipeline/src/util/sanitizer.ts", "../../node_modules/@azure/core-rest-pipeline/src/policies/logPolicy.ts", "../../node_modules/@azure/core-rest-pipeline/src/policies/redirectPolicy.ts", "../../node_modules/@azure/core-rest-pipeline/src/util/userAgentPlatform-browser.mts", "../../node_modules/@azure/core-rest-pipeline/src/constants.ts", "../../node_modules/@azure/core-rest-pipeline/src/util/userAgent.ts", "../../node_modules/@azure/core-rest-pipeline/src/policies/userAgentPolicy.ts", "../../node_modules/@azure/core-rest-pipeline/src/util/typeGuards.ts", "../../node_modules/@azure/core-rest-pipeline/src/util/file.ts", "../../node_modules/@azure/core-rest-pipeline/src/util/concat.common.ts", "../../node_modules/@azure/core-rest-pipeline/src/util/concat-browser.mts", "../../node_modules/@azure/core-rest-pipeline/src/policies/multipartPolicy.ts", "../../node_modules/@azure/core-rest-pipeline/src/policies/decompressResponsePolicy-browser.mts", "../../node_modules/@azure/core-rest-pipeline/node_modules/@azure/abort-controller/src/AbortError.ts", "../../node_modules/@azure/core-rest-pipeline/node_modules/@azure/abort-controller/src/index.ts", "../../node_modules/@azure/core-rest-pipeline/src/util/helpers.ts", "../../node_modules/@azure/core-rest-pipeline/src/retryStrategies/throttlingRetryStrategy.ts", "../../node_modules/@azure/core-rest-pipeline/src/retryStrategies/exponentialRetryStrategy.ts", "../../node_modules/@azure/core-rest-pipeline/src/policies/retryPolicy.ts", "../../node_modules/@azure/core-rest-pipeline/src/policies/defaultRetryPolicy.ts", "../../node_modules/@azure/core-rest-pipeline/src/httpHeaders.ts", "../../node_modules/@azure/core-rest-pipeline/src/policies/formDataPolicy.ts", "../../node_modules/@azure/core-rest-pipeline/src/policies/proxyPolicy.common.ts", "../../node_modules/@azure/core-rest-pipeline/src/policies/proxyPolicy-browser.mts", "../../node_modules/@azure/core-rest-pipeline/src/policies/setClientRequestIdPolicy.ts", "../../node_modules/@azure/core-rest-pipeline/src/policies/agentPolicy.ts", "../../node_modules/@azure/core-rest-pipeline/src/policies/tlsPolicy.ts", "../../node_modules/@azure/core-tracing/src/tracingContext.ts", "../../node_modules/@azure/core-tracing/src/state-browser.mts", "../../node_modules/@azure/core-tracing/src/instrumenter.ts", "../../node_modules/@azure/core-tracing/src/tracingClient.ts", "../../node_modules/@azure/core-tracing/src/index.ts", "../../node_modules/@azure/core-rest-pipeline/src/util/inspect.common.ts", "../../node_modules/@azure/core-rest-pipeline/src/util/inspect-browser.mts", "../../node_modules/@azure/core-rest-pipeline/src/restError.ts", "../../node_modules/@azure/core-rest-pipeline/src/policies/tracingPolicy.ts", "../../node_modules/@azure/core-rest-pipeline/src/createPipelineFromOptions.ts", "../../node_modules/@azure/core-rest-pipeline/src/fetchHttpClient.ts", "../../node_modules/@azure/core-rest-pipeline/src/defaultHttpClient-browser.mts", "../../node_modules/@azure/core-rest-pipeline/src/pipelineRequest.ts", "../../node_modules/@azure/core-rest-pipeline/src/policies/exponentialRetryPolicy.ts", "../../node_modules/@azure/core-rest-pipeline/src/policies/systemErrorRetryPolicy.ts", "../../node_modules/@azure/core-rest-pipeline/src/policies/throttlingRetryPolicy.ts", "../../node_modules/@azure/core-rest-pipeline/src/util/tokenCycler.ts", "../../node_modules/@azure/core-rest-pipeline/src/policies/bearerTokenAuthenticationPolicy.ts", "../../node_modules/@azure/core-rest-pipeline/src/policies/ndJsonPolicy.ts", "../../node_modules/@azure/core-rest-pipeline/src/policies/auxiliaryAuthenticationHeaderPolicy.ts", "../../node_modules/@azure/core-rest-pipeline/src/index.ts", "../../node_modules/@azure/communication-common/src/tokenParser.ts", "../../node_modules/@azure/communication-common/src/autoRefreshTokenCredential.ts", "../../node_modules/@azure/communication-common/src/staticTokenCredential.ts", "../../node_modules/@azure/communication-common/src/azureCommunicationTokenCredential.ts", "../../node_modules/@azure/communication-common/src/credential/encodeUtils.browser.ts", "../../node_modules/@azure/communication-common/src/credential/cryptoUtils.browser.ts", "../../node_modules/@azure/communication-common/src/credential/communicationAccessKeyCredentialPolicy.ts", "../../node_modules/@azure/communication-common/src/credential/communicationAuthPolicy.ts", "../../node_modules/@azure/core-auth/src/azureKeyCredential.ts", "../../node_modules/@azure/core-auth/src/keyCredential.ts", "../../node_modules/@azure/core-auth/src/azureNamedKeyCredential.ts", "../../node_modules/@azure/core-auth/src/azureSASCredential.ts", "../../node_modules/@azure/core-auth/src/tokenCredential.ts", "../../node_modules/@azure/communication-common/src/credential/connectionString.ts", "../../node_modules/@azure/communication-common/src/credential/clientArguments.ts", "../../node_modules/@azure/communication-common/src/identifierModels.ts", "../../node_modules/@azure/communication-common/src/identifierModelSerializer.ts"],
  "sourcesContent": ["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\n/**\n * This error is thrown when an asynchronous operation has been aborted.\n * Check for this error by testing the `name` that the name property of the\n * error matches `\"AbortError\"`.\n *\n * @example\n * ```ts\n * const controller = new AbortController();\n * controller.abort();\n * try {\n *   doAsyncWork(controller.signal)\n * } catch (e) {\n *   if (e.name === 'AbortError') {\n *     // handle abort error here.\n *   }\n * }\n * ```\n */\nexport class AbortError extends Error {\n  constructor(message?: string) {\n    super(message);\n    this.name = \"AbortError\";\n  }\n}\n", "// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\ndeclare global {\n  interface Event {}\n}\n\nexport { AbortError } from \"./AbortError.js\";\nexport { AbortSignalLike } from \"./AbortSignalLike.js\";\n", "// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\n\nimport { AbortError } from \"@azure/abort-controller\";\nimport type { AbortOptions } from \"./aborterUtils.js\";\n\n/**\n * Options for the createAbortablePromise function.\n */\nexport interface CreateAbortablePromiseOptions extends AbortOptions {\n  /** A function to be called if the promise was aborted */\n  cleanupBeforeAbort?: () => void;\n}\n\n/**\n * Creates an abortable promise.\n * @param buildPromise - A function that takes the resolve and reject functions as parameters.\n * @param options - The options for the abortable promise.\n * @returns A promise that can be aborted.\n */\nexport function createAbortablePromise<T>(\n  buildPromise: (\n    resolve: (value: T | PromiseLike<T>) => void,\n    reject: (reason?: any) => void,\n  ) => void,\n  options?: CreateAbortablePromiseOptions,\n): Promise<T> {\n  const { cleanupBeforeAbort, abortSignal, abortErrorMsg } = options ?? {};\n  return new Promise((resolve, reject) => {\n    function rejectOnAbort(): void {\n      reject(new AbortError(abortErrorMsg ?? \"The operation was aborted.\"));\n    }\n    function removeListeners(): void {\n      abortSignal?.removeEventListener(\"abort\", onAbort);\n    }\n    function onAbort(): void {\n      cleanupBeforeAbort?.();\n      removeListeners();\n      rejectOnAbort();\n    }\n    if (abortSignal?.aborted) {\n      return rejectOnAbort();\n    }\n    try {\n      buildPromise(\n        (x) => {\n          removeListeners();\n          resolve(x);\n        },\n        (x) => {\n          removeListeners();\n          reject(x);\n        },\n      );\n    } catch (err) {\n      reject(err);\n    }\n    abortSignal?.addEventListener(\"abort\", onAbort);\n  });\n}\n", "// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\n\n/**\n * Returns a random integer value between a lower and upper bound,\n * inclusive of both bounds.\n * Note that this uses Math.random and isn't secure. If you need to use\n * this for any kind of security purpose, find a better source of random.\n * @param min - The smallest integer value allowed.\n * @param max - The largest integer value allowed.\n */\nexport function getRandomIntegerInclusive(min: number, max: number): number {\n  // Make sure inputs are integers.\n  min = Math.ceil(min);\n  max = Math.floor(max);\n  // Pick a random offset from zero to the size of the range.\n  // Since Math.random() can never return 1, we have to make the range one larger\n  // in order to be inclusive of the maximum value after we take the floor.\n  const offset = Math.floor(Math.random() * (max - min + 1));\n  return offset + min;\n}\n", "// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\n\nimport type { AbortOptions } from \"./aborterUtils.js\";\nimport { createAbortablePromise } from \"./createAbortablePromise.js\";\nimport { getRandomIntegerInclusive } from \"./random.js\";\n\nconst StandardAbortMessage = \"The delay was aborted.\";\n\n/**\n * Options for support abort functionality for the delay method\n */\nexport interface DelayOptions extends AbortOptions {}\n\n/**\n * A wrapper for setTimeout that resolves a promise after timeInMs milliseconds.\n * @param timeInMs - The number of milliseconds to be delayed.\n * @param options - The options for delay - currently abort options\n * @returns Promise that is resolved after timeInMs\n */\nexport function delay(timeInMs: number, options?: DelayOptions): Promise<void> {\n  let token: ReturnType<typeof setTimeout>;\n  const { abortSignal, abortErrorMsg } = options ?? {};\n  return createAbortablePromise(\n    (resolve) => {\n      token = setTimeout(resolve, timeInMs);\n    },\n    {\n      cleanupBeforeAbort: () => clearTimeout(token),\n      abortSignal,\n      abortErrorMsg: abortErrorMsg ?? StandardAbortMessage,\n    },\n  );\n}\n\n/**\n * Calculates the delay interval for retry attempts using exponential delay with jitter.\n * @param retryAttempt - The current retry attempt number.\n * @param config - The exponential retry configuration.\n * @returns An object containing the calculated retry delay.\n */\nexport function calculateRetryDelay(\n  retryAttempt: number,\n  config: {\n    retryDelayInMs: number;\n    maxRetryDelayInMs: number;\n  },\n): { retryAfterInMs: number } {\n  // Exponentially increase the delay each time\n  const exponentialDelay = config.retryDelayInMs * Math.pow(2, retryAttempt);\n\n  // Don't let the delay exceed the maximum\n  const clampedDelay = Math.min(config.maxRetryDelayInMs, exponentialDelay);\n\n  // Allow the final value to have some \"jitter\" (within 50% of the delay size) so\n  // that retries across multiple clients don't occur simultaneously.\n  const retryAfterInMs = clampedDelay / 2 + getRandomIntegerInclusive(0, clampedDelay / 2);\n\n  return { retryAfterInMs };\n}\n", "// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\n\nimport type { AbortSignalLike } from \"@azure/abort-controller\";\n\n/**\n * Options related to abort controller.\n */\nexport interface AbortOptions {\n  /**\n   * The abortSignal associated with containing operation.\n   */\n  abortSignal?: AbortSignalLike;\n  /**\n   * The abort error message associated with containing operation.\n   */\n  abortErrorMsg?: string;\n}\n\n/**\n * Represents a function that returns a promise that can be aborted.\n */\nexport type AbortablePromiseBuilder<T> = (abortOptions: {\n  abortSignal?: AbortSignalLike;\n}) => Promise<T>;\n\n/**\n * promise.race() wrapper that aborts rest of promises as soon as the first promise settles.\n */\nexport async function cancelablePromiseRace<T extends unknown[]>(\n  abortablePromiseBuilders: AbortablePromiseBuilder<T[number]>[],\n  options?: { abortSignal?: AbortSignalLike },\n): Promise<T[number]> {\n  const aborter = new AbortController();\n  function abortHandler(): void {\n    aborter.abort();\n  }\n  options?.abortSignal?.addEventListener(\"abort\", abortHandler);\n  try {\n    return await Promise.race(\n      abortablePromiseBuilders.map((p) => p({ abortSignal: aborter.signal })),\n    );\n  } finally {\n    aborter.abort();\n    options?.abortSignal?.removeEventListener(\"abort\", abortHandler);\n  }\n}\n", "// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\n\n/**\n * A generic shape for a plain JS object.\n */\nexport type UnknownObject = { [s: string]: unknown };\n\n/**\n * Helper to determine when an input is a generic JS object.\n * @returns true when input is an object type that is not null, Array, RegExp, or Date.\n */\nexport function isObject(input: unknown): input is UnknownObject {\n  return (\n    typeof input === \"object\" &&\n    input !== null &&\n    !Array.isArray(input) &&\n    !(input instanceof RegExp) &&\n    !(input instanceof Date)\n  );\n}\n", "// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\n\nimport { isObject } from \"./object.js\";\n\n/**\n * Typeguard for an error object shape (has name and message)\n * @param e - Something caught by a catch clause.\n */\nexport function isError(e: unknown): e is Error {\n  if (isObject(e)) {\n    const hasName = typeof e.name === \"string\";\n    const hasMessage = typeof e.message === \"string\";\n    return hasName && hasMessage;\n  }\n  return false;\n}\n\n/**\n * Given what is thought to be an error object, return the message if possible.\n * If the message is missing, returns a stringified version of the input.\n * @param e - Something thrown from a try block\n * @returns The error message or a string of the input\n */\nexport function getErrorMessage(e: unknown): string {\n  if (isError(e)) {\n    return e.message;\n  } else {\n    let stringified: string;\n    try {\n      if (typeof e === \"object\" && e) {\n        stringified = JSON.stringify(e);\n      } else {\n        stringified = String(e);\n      }\n    } catch (err: any) {\n      stringified = \"[unable to stringify input]\";\n    }\n    return `Unknown error ${stringified}`;\n  }\n}\n", "// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\n\ndeclare global {\n  // stub these out for the browser\n  function btoa(input: string): string;\n  function atob(input: string): string;\n}\n\n/** The supported character encoding type */\nexport type EncodingType = \"utf-8\" | \"base64\" | \"base64url\" | \"hex\";\n\n/**\n * The helper that transforms bytes with specific character encoding into string\n * @param bytes - the uint8array bytes\n * @param format - the format we use to encode the byte\n * @returns a string of the encoded string\n */\nexport function uint8ArrayToString(bytes: Uint8Array, format: EncodingType): string {\n  switch (format) {\n    case \"utf-8\":\n      return uint8ArrayToUtf8String(bytes);\n    case \"base64\":\n      return uint8ArrayToBase64(bytes);\n    case \"base64url\":\n      return uint8ArrayToBase64Url(bytes);\n    case \"hex\":\n      return uint8ArrayToHexString(bytes);\n  }\n}\n\n/**\n * The helper that transforms string to specific character encoded bytes array.\n * @param value - the string to be converted\n * @param format - the format we use to decode the value\n * @returns a uint8array\n */\nexport function stringToUint8Array(value: string, format: EncodingType): Uint8Array {\n  switch (format) {\n    case \"utf-8\":\n      return utf8StringToUint8Array(value);\n    case \"base64\":\n      return base64ToUint8Array(value);\n    case \"base64url\":\n      return base64UrlToUint8Array(value);\n    case \"hex\":\n      return hexStringToUint8Array(value);\n  }\n}\n\n/**\n * Decodes a Uint8Array into a Base64 string.\n * @internal\n */\nexport function uint8ArrayToBase64(bytes: Uint8Array): string {\n  return btoa([...bytes].map((x) => String.fromCharCode(x)).join(\"\"));\n}\n\n/**\n * Decodes a Uint8Array into a Base64Url string.\n * @internal\n */\nexport function uint8ArrayToBase64Url(bytes: Uint8Array): string {\n  return uint8ArrayToBase64(bytes).replace(/\\+/g, \"-\").replace(/\\//g, \"_\").replace(/=/g, \"\");\n}\n\n/**\n * Decodes a Uint8Array into a javascript string.\n * @internal\n */\nexport function uint8ArrayToUtf8String(bytes: Uint8Array): string {\n  const decoder = new TextDecoder();\n  const dataString = decoder.decode(bytes);\n  return dataString;\n}\n\n/**\n * Decodes a Uint8Array into a hex string\n * @internal\n */\nexport function uint8ArrayToHexString(bytes: Uint8Array): string {\n  return [...bytes].map((x) => x.toString(16).padStart(2, \"0\")).join(\"\");\n}\n\n/**\n * Encodes a JavaScript string into a Uint8Array.\n * @internal\n */\nexport function utf8StringToUint8Array(value: string): Uint8Array {\n  return new TextEncoder().encode(value);\n}\n\n/**\n * Encodes a Base64 string into a Uint8Array.\n * @internal\n */\nexport function base64ToUint8Array(value: string): Uint8Array {\n  return new Uint8Array([...atob(value)].map((x) => x.charCodeAt(0)));\n}\n\n/**\n * Encodes a Base64Url string into a Uint8Array.\n * @internal\n */\nexport function base64UrlToUint8Array(value: string): Uint8Array {\n  const base64String = value.replace(/-/g, \"+\").replace(/_/g, \"/\");\n  return base64ToUint8Array(base64String);\n}\n\nconst hexDigits = new Set(\"0123456789abcdefABCDEF\");\n\n/**\n * Encodes a hex string into a Uint8Array\n * @internal\n */\nexport function hexStringToUint8Array(value: string): Uint8Array {\n  // If value has odd length, the last character will be ignored, consistent with NodeJS Buffer behavior\n  const bytes = new Uint8Array(value.length / 2);\n  for (let i = 0; i < value.length / 2; ++i) {\n    const highNibble = value[2 * i];\n    const lowNibble = value[2 * i + 1];\n    if (!hexDigits.has(highNibble) || !hexDigits.has(lowNibble)) {\n      // Replicate Node Buffer behavior by exiting early when we encounter an invalid byte\n      return bytes.slice(0, i);\n    }\n\n    bytes[i] = parseInt(`${highNibble}${lowNibble}`, 16);\n  }\n\n  return bytes;\n}\n", "// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\n\nexport * from \"./bytesEncoding.common.js\";\n", "// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\n\nimport { stringToUint8Array, uint8ArrayToString } from \"./bytesEncoding.js\";\n\n// stubs for browser self.crypto\ninterface JsonWebKey {}\ninterface CryptoKey {}\ntype KeyUsage =\n  | \"decrypt\"\n  | \"deriveBits\"\n  | \"deriveKey\"\n  | \"encrypt\"\n  | \"sign\"\n  | \"unwrapKey\"\n  | \"verify\"\n  | \"wrapKey\";\ninterface Algorithm {\n  name: string;\n}\ninterface SubtleCrypto {\n  importKey(\n    format: string,\n    keyData: JsonWebKey,\n    algorithm: HmacImportParams,\n    extractable: boolean,\n    usage: KeyUsage[],\n  ): Promise<CryptoKey>;\n  sign(\n    algorithm: HmacImportParams,\n    key: CryptoKey,\n    data: ArrayBufferView | ArrayBuffer,\n  ): Promise<ArrayBuffer>;\n  digest(algorithm: Algorithm, data: ArrayBufferView | ArrayBuffer): Promise<ArrayBuffer>;\n}\ninterface Crypto {\n  readonly subtle: SubtleCrypto;\n  getRandomValues<T extends ArrayBufferView | null>(array: T): T;\n}\ndeclare const self: {\n  crypto: Crypto;\n};\ninterface HmacImportParams {\n  name: string;\n  hash: Algorithm;\n  length?: number;\n}\n\nlet subtleCrypto: SubtleCrypto | undefined;\n\n/**\n * Returns a cached reference to the Web API crypto.subtle object.\n * @internal\n */\nfunction getCrypto(): SubtleCrypto {\n  if (subtleCrypto) {\n    return subtleCrypto;\n  }\n\n  if (!self.crypto || !self.crypto.subtle) {\n    throw new Error(\"Your browser environment does not support cryptography functions.\");\n  }\n\n  subtleCrypto = self.crypto.subtle;\n  return subtleCrypto;\n}\n\n/**\n * Generates a SHA-256 HMAC signature.\n * @param key - The HMAC key represented as a base64 string, used to generate the cryptographic HMAC hash.\n * @param stringToSign - The data to be signed.\n * @param encoding - The textual encoding to use for the returned HMAC digest.\n */\nexport async function computeSha256Hmac(\n  key: string,\n  stringToSign: string,\n  encoding: \"base64\" | \"hex\",\n): Promise<string> {\n  const crypto = getCrypto();\n  const keyBytes = stringToUint8Array(key, \"base64\");\n  const stringToSignBytes = stringToUint8Array(stringToSign, \"utf-8\");\n\n  const cryptoKey = await crypto.importKey(\n    \"raw\",\n    keyBytes,\n    {\n      name: \"HMAC\",\n      hash: { name: \"SHA-256\" },\n    },\n    false,\n    [\"sign\"],\n  );\n  const signature = await crypto.sign(\n    {\n      name: \"HMAC\",\n      hash: { name: \"SHA-256\" },\n    },\n    cryptoKey,\n    stringToSignBytes,\n  );\n\n  return uint8ArrayToString(new Uint8Array(signature), encoding);\n}\n\n/**\n * Generates a SHA-256 hash.\n * @param content - The data to be included in the hash.\n * @param encoding - The textual encoding to use for the returned hash.\n */\nexport async function computeSha256Hash(\n  content: string,\n  encoding: \"base64\" | \"hex\",\n): Promise<string> {\n  const contentBytes = stringToUint8Array(content, \"utf-8\");\n  const digest = await getCrypto().digest({ name: \"SHA-256\" }, contentBytes);\n\n  return uint8ArrayToString(new Uint8Array(digest), encoding);\n}\n", "// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\n\nexport * from \"./sha256.common.js\";\n", "// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\n\n/**\n * Helper TypeGuard that checks if something is defined or not.\n * @param thing - Anything\n */\nexport function isDefined<T>(thing: T | undefined | null): thing is T {\n  return typeof thing !== \"undefined\" && thing !== null;\n}\n\n/**\n * Helper TypeGuard that checks if the input is an object with the specified properties.\n * @param thing - Anything.\n * @param properties - The name of the properties that should appear in the object.\n */\nexport function isObjectWithProperties<Thing, PropertyName extends string>(\n  thing: Thing,\n  properties: PropertyName[],\n): thing is Thing & Record<PropertyName, unknown> {\n  if (!isDefined(thing) || typeof thing !== \"object\") {\n    return false;\n  }\n\n  for (const property of properties) {\n    if (!objectHasProperty(thing, property)) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\n/**\n * Helper TypeGuard that checks if the input is an object with the specified property.\n * @param thing - Any object.\n * @param property - The name of the property that should appear in the object.\n */\nexport function objectHasProperty<Thing, PropertyName extends string>(\n  thing: Thing,\n  property: PropertyName,\n): thing is Thing & Record<PropertyName, unknown> {\n  return (\n    isDefined(thing) && typeof thing === \"object\" && property in (thing as Record<string, unknown>)\n  );\n}\n", "// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\n\n/**\n * Generated Universally Unique Identifier\n *\n * @returns RFC4122 v4 UUID.\n */\nexport function generateUUID(): string {\n  let uuid = \"\";\n  for (let i = 0; i < 32; i++) {\n    // Generate a random number between 0 and 15\n    const randomNumber = Math.floor(Math.random() * 16);\n    // Set the UUID version to 4 in the 13th position\n    if (i === 12) {\n      uuid += \"4\";\n    } else if (i === 16) {\n      // Set the UUID variant to \"10\" in the 17th position\n      uuid += (randomNumber & 0x3) | 0x8;\n    } else {\n      // Add a random hexadecimal digit to the UUID string\n      uuid += randomNumber.toString(16);\n    }\n    // Add hyphens to the UUID string at the appropriate positions\n    if (i === 7 || i === 11 || i === 15 || i === 19) {\n      uuid += \"-\";\n    }\n  }\n  return uuid;\n}\n\n/**\n * Generated Universally Unique Identifier\n *\n * @returns RFC4122 v4 UUID.\n */\nexport function randomUUID(): string {\n  return generateUUID();\n}\n", "// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\n\nimport { generateUUID } from \"./uuidUtils.common.js\";\n\ninterface Crypto {\n  randomUUID(): string;\n}\n\ndeclare const globalThis: {\n  crypto: Crypto;\n};\n\n// NOTE: This could be undefined if not used in a secure context\nconst uuidFunction =\n  typeof globalThis?.crypto?.randomUUID === \"function\"\n    ? globalThis.crypto.randomUUID.bind(globalThis.crypto)\n    : generateUUID;\n\n/**\n * Generated Universally Unique Identifier\n *\n * @returns RFC4122 v4 UUID.\n */\nexport function randomUUID(): string {\n  return uuidFunction();\n}\n", "// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\n\ninterface Window {\n  document: unknown;\n}\n\ninterface DedicatedWorkerGlobalScope {\n  constructor: {\n    name: string;\n  };\n\n  importScripts: (...paths: string[]) => void;\n}\n\ninterface Navigator {\n  product: string;\n}\n\ninterface DenoGlobal {\n  version: {\n    deno: string;\n  };\n}\n\ninterface BunGlobal {\n  version: string;\n}\n\n// eslint-disable-next-line @azure/azure-sdk/ts-no-window\ndeclare const window: Window;\ndeclare const self: DedicatedWorkerGlobalScope;\ndeclare const Deno: DenoGlobal;\ndeclare const Bun: BunGlobal;\ndeclare const navigator: Navigator;\n\n/**\n * A constant that indicates whether the environment the code is running is a Web Browser.\n */\n// eslint-disable-next-line @azure/azure-sdk/ts-no-window\nexport const isBrowser = typeof window !== \"undefined\" && typeof window.document !== \"undefined\";\n\n/**\n * A constant that indicates whether the environment the code is running is a Web Worker.\n */\nexport const isWebWorker =\n  typeof self === \"object\" &&\n  typeof self?.importScripts === \"function\" &&\n  (self.constructor?.name === \"DedicatedWorkerGlobalScope\" ||\n    self.constructor?.name === \"ServiceWorkerGlobalScope\" ||\n    self.constructor?.name === \"SharedWorkerGlobalScope\");\n\n/**\n * A constant that indicates whether the environment the code is running is Deno.\n */\nexport const isDeno =\n  typeof Deno !== \"undefined\" &&\n  typeof Deno.version !== \"undefined\" &&\n  typeof Deno.version.deno !== \"undefined\";\n\n/**\n * A constant that indicates whether the environment the code is running is Bun.sh.\n */\nexport const isBun = typeof Bun !== \"undefined\" && typeof Bun.version !== \"undefined\";\n\n/**\n * A constant that indicates whether the environment the code is running is a Node.js compatible environment.\n */\nexport const isNodeLike =\n  typeof globalThis.process !== \"undefined\" &&\n  Boolean(globalThis.process.version) &&\n  Boolean(globalThis.process.versions?.node);\n\n/**\n * A constant that indicates whether the environment the code is running is a Node.js compatible environment.\n * @deprecated Use `isNodeLike` instead.\n */\nexport const isNode = isNodeLike;\n\n/**\n * A constant that indicates whether the environment the code is running is Node.JS.\n */\nexport const isNodeRuntime = isNodeLike && !isBun && !isDeno;\n\n/**\n * A constant that indicates whether the environment the code is running is in React-Native.\n */\n// https://github.com/facebook/react-native/blob/main/packages/react-native/Libraries/Core/setUpNavigator.js\nexport const isReactNative =\n  typeof navigator !== \"undefined\" && navigator?.product === \"ReactNative\";\n", "// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\n\nexport { delay, type DelayOptions, calculateRetryDelay } from \"./delay.js\";\nexport {\n  type AbortOptions,\n  cancelablePromiseRace,\n  type AbortablePromiseBuilder,\n} from \"./aborterUtils.js\";\nexport {\n  createAbortablePromise,\n  type CreateAbortablePromiseOptions,\n} from \"./createAbortablePromise.js\";\nexport { getRandomIntegerInclusive } from \"./random.js\";\nexport { isObject, type UnknownObject } from \"./object.js\";\nexport { isError, getErrorMessage } from \"./error.js\";\nexport { computeSha256Hash, computeSha256Hmac } from \"./sha256.js\";\nexport { isDefined, isObjectWithProperties, objectHasProperty } from \"./typeGuards.js\";\nexport { randomUUID } from \"./uuidUtils.js\";\nexport { HttpMethods } from \"./httpMethods.js\";\nexport {\n  isBrowser,\n  isBun,\n  isNode,\n  isNodeLike,\n  isNodeRuntime,\n  isDeno,\n  isReactNative,\n  isWebWorker,\n} from \"./checkEnvironment.js\";\nexport { uint8ArrayToString, stringToUint8Array, type EncodingType } from \"./bytesEncoding.js\";\n", "// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\n\nimport type { HttpClient, PipelineRequest, PipelineResponse, SendRequest } from \"./interfaces.js\";\n\n/**\n * Policies are executed in phases.\n * The execution order is:\n * 1. Serialize Phase\n * 2. Policies not in a phase\n * 3. Deserialize Phase\n * 4. Retry Phase\n * 5. Sign Phase\n */\nexport type PipelinePhase = \"Deserialize\" | \"Serialize\" | \"Retry\" | \"Sign\";\n\nconst ValidPhaseNames = new Set<PipelinePhase>([\"Deserialize\", \"Serialize\", \"Retry\", \"Sign\"]);\n\n/**\n * Options when adding a policy to the pipeline.\n * Used to express dependencies on other policies.\n */\nexport interface AddPolicyOptions {\n  /**\n   * Policies that this policy must come before.\n   */\n  beforePolicies?: string[];\n  /**\n   * Policies that this policy must come after.\n   */\n  afterPolicies?: string[];\n  /**\n   * The phase that this policy must come after.\n   */\n  afterPhase?: PipelinePhase;\n  /**\n   * The phase this policy belongs to.\n   */\n  phase?: PipelinePhase;\n}\n\n/**\n * A pipeline policy manipulates a request as it travels through the pipeline.\n * It is conceptually a middleware that is allowed to modify the request before\n * it is made as well as the response when it is received.\n */\nexport interface PipelinePolicy {\n  /**\n   * The policy name. Must be a unique string in the pipeline.\n   */\n  name: string;\n  /**\n   * The main method to implement that manipulates a request/response.\n   * @param request - The request being performed.\n   * @param next - The next policy in the pipeline. Must be called to continue the pipeline.\n   */\n  sendRequest(request: PipelineRequest, next: SendRequest): Promise<PipelineResponse>;\n}\n\n/**\n * Represents a pipeline for making a HTTP request to a URL.\n * Pipelines can have multiple policies to manage manipulating each request\n * before and after it is made to the server.\n */\nexport interface Pipeline {\n  /**\n   * Add a new policy to the pipeline.\n   * @param policy - A policy that manipulates a request.\n   * @param options - A set of options for when the policy should run.\n   */\n  addPolicy(policy: PipelinePolicy, options?: AddPolicyOptions): void;\n  /**\n   * Remove a policy from the pipeline.\n   * @param options - Options that let you specify which policies to remove.\n   */\n  removePolicy(options: { name?: string; phase?: PipelinePhase }): PipelinePolicy[];\n  /**\n   * Uses the pipeline to make a HTTP request.\n   * @param httpClient - The HttpClient that actually performs the request.\n   * @param request - The request to be made.\n   */\n  sendRequest(httpClient: HttpClient, request: PipelineRequest): Promise<PipelineResponse>;\n  /**\n   * Returns the current set of policies in the pipeline in the order in which\n   * they will be applied to the request. Later in the list is closer to when\n   * the request is performed.\n   */\n  getOrderedPolicies(): PipelinePolicy[];\n  /**\n   * Duplicates this pipeline to allow for modifying an existing one without mutating it.\n   */\n  clone(): Pipeline;\n}\n\ninterface PipelineDescriptor {\n  policy: PipelinePolicy;\n  options: AddPolicyOptions;\n}\n\ninterface PolicyGraphNode {\n  policy: PipelinePolicy;\n  dependsOn: Set<PolicyGraphNode>;\n  dependants: Set<PolicyGraphNode>;\n  afterPhase?: Phase;\n}\n\ninterface Phase {\n  name: PipelinePhase | \"None\";\n  policies: Set<PolicyGraphNode>;\n  hasRun: boolean;\n  hasAfterPolicies: boolean;\n}\n\n/**\n * A private implementation of Pipeline.\n * Do not export this class from the package.\n * @internal\n */\nclass HttpPipeline implements Pipeline {\n  private _policies: PipelineDescriptor[] = [];\n  private _orderedPolicies?: PipelinePolicy[];\n\n  private constructor(policies?: PipelineDescriptor[]) {\n    this._policies = policies?.slice(0) ?? [];\n    this._orderedPolicies = undefined;\n  }\n\n  public addPolicy(policy: PipelinePolicy, options: AddPolicyOptions = {}): void {\n    if (options.phase && options.afterPhase) {\n      throw new Error(\"Policies inside a phase cannot specify afterPhase.\");\n    }\n    if (options.phase && !ValidPhaseNames.has(options.phase)) {\n      throw new Error(`Invalid phase name: ${options.phase}`);\n    }\n    if (options.afterPhase && !ValidPhaseNames.has(options.afterPhase)) {\n      throw new Error(`Invalid afterPhase name: ${options.afterPhase}`);\n    }\n    this._policies.push({\n      policy,\n      options,\n    });\n    this._orderedPolicies = undefined;\n  }\n\n  public removePolicy(options: { name?: string; phase?: string }): PipelinePolicy[] {\n    const removedPolicies: PipelinePolicy[] = [];\n\n    this._policies = this._policies.filter((policyDescriptor) => {\n      if (\n        (options.name && policyDescriptor.policy.name === options.name) ||\n        (options.phase && policyDescriptor.options.phase === options.phase)\n      ) {\n        removedPolicies.push(policyDescriptor.policy);\n        return false;\n      } else {\n        return true;\n      }\n    });\n    this._orderedPolicies = undefined;\n\n    return removedPolicies;\n  }\n\n  public sendRequest(httpClient: HttpClient, request: PipelineRequest): Promise<PipelineResponse> {\n    const policies = this.getOrderedPolicies();\n\n    const pipeline = policies.reduceRight<SendRequest>(\n      (next, policy) => {\n        return (req: PipelineRequest) => {\n          return policy.sendRequest(req, next);\n        };\n      },\n      (req: PipelineRequest) => httpClient.sendRequest(req),\n    );\n\n    return pipeline(request);\n  }\n\n  public getOrderedPolicies(): PipelinePolicy[] {\n    if (!this._orderedPolicies) {\n      this._orderedPolicies = this.orderPolicies();\n    }\n    return this._orderedPolicies;\n  }\n\n  public clone(): Pipeline {\n    return new HttpPipeline(this._policies);\n  }\n\n  public static create(): Pipeline {\n    return new HttpPipeline();\n  }\n\n  private orderPolicies(): PipelinePolicy[] {\n    /**\n     * The goal of this method is to reliably order pipeline policies\n     * based on their declared requirements when they were added.\n     *\n     * Order is first determined by phase:\n     *\n     * 1. Serialize Phase\n     * 2. Policies not in a phase\n     * 3. Deserialize Phase\n     * 4. Retry Phase\n     * 5. Sign Phase\n     *\n     * Within each phase, policies are executed in the order\n     * they were added unless they were specified to execute\n     * before/after other policies or after a particular phase.\n     *\n     * To determine the final order, we will walk the policy list\n     * in phase order multiple times until all dependencies are\n     * satisfied.\n     *\n     * `afterPolicies` are the set of policies that must be\n     * executed before a given policy. This requirement is\n     * considered satisfied when each of the listed policies\n     * have been scheduled.\n     *\n     * `beforePolicies` are the set of policies that must be\n     * executed after a given policy. Since this dependency\n     * can be expressed by converting it into a equivalent\n     * `afterPolicies` declarations, they are normalized\n     * into that form for simplicity.\n     *\n     * An `afterPhase` dependency is considered satisfied when all\n     * policies in that phase have scheduled.\n     *\n     */\n    const result: PipelinePolicy[] = [];\n\n    // Track all policies we know about.\n    const policyMap: Map<string, PolicyGraphNode> = new Map<string, PolicyGraphNode>();\n\n    function createPhase(name: PipelinePhase | \"None\"): Phase {\n      return {\n        name,\n        policies: new Set<PolicyGraphNode>(),\n        hasRun: false,\n        hasAfterPolicies: false,\n      };\n    }\n\n    // Track policies for each phase.\n    const serializePhase = createPhase(\"Serialize\");\n    const noPhase = createPhase(\"None\");\n    const deserializePhase = createPhase(\"Deserialize\");\n    const retryPhase = createPhase(\"Retry\");\n    const signPhase = createPhase(\"Sign\");\n\n    // a list of phases in order\n    const orderedPhases = [serializePhase, noPhase, deserializePhase, retryPhase, signPhase];\n\n    // Small helper function to map phase name to each Phase\n    function getPhase(phase: PipelinePhase | undefined): Phase {\n      if (phase === \"Retry\") {\n        return retryPhase;\n      } else if (phase === \"Serialize\") {\n        return serializePhase;\n      } else if (phase === \"Deserialize\") {\n        return deserializePhase;\n      } else if (phase === \"Sign\") {\n        return signPhase;\n      } else {\n        return noPhase;\n      }\n    }\n\n    // First walk each policy and create a node to track metadata.\n    for (const descriptor of this._policies) {\n      const policy = descriptor.policy;\n      const options = descriptor.options;\n      const policyName = policy.name;\n      if (policyMap.has(policyName)) {\n        throw new Error(\"Duplicate policy names not allowed in pipeline\");\n      }\n      const node: PolicyGraphNode = {\n        policy,\n        dependsOn: new Set<PolicyGraphNode>(),\n        dependants: new Set<PolicyGraphNode>(),\n      };\n      if (options.afterPhase) {\n        node.afterPhase = getPhase(options.afterPhase);\n        node.afterPhase.hasAfterPolicies = true;\n      }\n      policyMap.set(policyName, node);\n      const phase = getPhase(options.phase);\n      phase.policies.add(node);\n    }\n\n    // Now that each policy has a node, connect dependency references.\n    for (const descriptor of this._policies) {\n      const { policy, options } = descriptor;\n      const policyName = policy.name;\n      const node = policyMap.get(policyName);\n      if (!node) {\n        throw new Error(`Missing node for policy ${policyName}`);\n      }\n\n      if (options.afterPolicies) {\n        for (const afterPolicyName of options.afterPolicies) {\n          const afterNode = policyMap.get(afterPolicyName);\n          if (afterNode) {\n            // Linking in both directions helps later\n            // when we want to notify dependants.\n            node.dependsOn.add(afterNode);\n            afterNode.dependants.add(node);\n          }\n        }\n      }\n      if (options.beforePolicies) {\n        for (const beforePolicyName of options.beforePolicies) {\n          const beforeNode = policyMap.get(beforePolicyName);\n          if (beforeNode) {\n            // To execute before another node, make it\n            // depend on the current node.\n            beforeNode.dependsOn.add(node);\n            node.dependants.add(beforeNode);\n          }\n        }\n      }\n    }\n\n    function walkPhase(phase: Phase): void {\n      phase.hasRun = true;\n      // Sets iterate in insertion order\n      for (const node of phase.policies) {\n        if (node.afterPhase && (!node.afterPhase.hasRun || node.afterPhase.policies.size)) {\n          // If this node is waiting on a phase to complete,\n          // we need to skip it for now.\n          // Even if the phase is empty, we should wait for it\n          // to be walked to avoid re-ordering policies.\n          continue;\n        }\n        if (node.dependsOn.size === 0) {\n          // If there's nothing else we're waiting for, we can\n          // add this policy to the result list.\n          result.push(node.policy);\n          // Notify anything that depends on this policy that\n          // the policy has been scheduled.\n          for (const dependant of node.dependants) {\n            dependant.dependsOn.delete(node);\n          }\n          policyMap.delete(node.policy.name);\n          phase.policies.delete(node);\n        }\n      }\n    }\n\n    function walkPhases(): void {\n      for (const phase of orderedPhases) {\n        walkPhase(phase);\n        // if the phase isn't complete\n        if (phase.policies.size > 0 && phase !== noPhase) {\n          if (!noPhase.hasRun) {\n            // Try running noPhase to see if that unblocks this phase next tick.\n            // This can happen if a phase that happens before noPhase\n            // is waiting on a noPhase policy to complete.\n            walkPhase(noPhase);\n          }\n          // Don't proceed to the next phase until this phase finishes.\n          return;\n        }\n\n        if (phase.hasAfterPolicies) {\n          // Run any policies unblocked by this phase\n          walkPhase(noPhase);\n        }\n      }\n    }\n\n    // Iterate until we've put every node in the result list.\n    let iteration = 0;\n    while (policyMap.size > 0) {\n      iteration++;\n      const initialResultLength = result.length;\n      // Keep walking each phase in order until we can order every node.\n      walkPhases();\n      // The result list *should* get at least one larger each time\n      // after the first full pass.\n      // Otherwise, we're going to loop forever.\n      if (result.length <= initialResultLength && iteration > 1) {\n        throw new Error(\"Cannot satisfy policy dependencies due to requirements cycle.\");\n      }\n    }\n\n    return result;\n  }\n}\n\n/**\n * Creates a totally empty pipeline.\n * Useful for testing or creating a custom one.\n */\nexport function createEmptyPipeline(): Pipeline {\n  return HttpPipeline.create();\n}\n", "// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\n\nimport { createClientLogger } from \"@azure/logger\";\nexport const logger = createClientLogger(\"core-rest-pipeline\");\n", "// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\n\nimport { type UnknownObject, isObject } from \"@azure/core-util\";\n\n/**\n * @internal\n */\nexport interface SanitizerOptions {\n  /**\n   * Header names whose values will be logged when logging is enabled.\n   * Defaults include a list of well-known safe headers. Any headers\n   * specified in this field will be added to that list.  Any other values will\n   * be written to logs as \"REDACTED\".\n   */\n  additionalAllowedHeaderNames?: string[];\n\n  /**\n   * Query string names whose values will be logged when logging is enabled. By default no\n   * query string values are logged.\n   */\n  additionalAllowedQueryParameters?: string[];\n}\n\nconst RedactedString = \"REDACTED\";\n\n// Make sure this list is up-to-date with the one under core/logger/Readme#Keyconcepts\nconst defaultAllowedHeaderNames = [\n  \"x-ms-client-request-id\",\n  \"x-ms-return-client-request-id\",\n  \"x-ms-useragent\",\n  \"x-ms-correlation-request-id\",\n  \"x-ms-request-id\",\n  \"client-request-id\",\n  \"ms-cv\",\n  \"return-client-request-id\",\n  \"traceparent\",\n\n  \"Access-Control-Allow-Credentials\",\n  \"Access-Control-Allow-Headers\",\n  \"Access-Control-Allow-Methods\",\n  \"Access-Control-Allow-Origin\",\n  \"Access-Control-Expose-Headers\",\n  \"Access-Control-Max-Age\",\n  \"Access-Control-Request-Headers\",\n  \"Access-Control-Request-Method\",\n  \"Origin\",\n\n  \"Accept\",\n  \"Accept-Encoding\",\n  \"Cache-Control\",\n  \"Connection\",\n  \"Content-Length\",\n  \"Content-Type\",\n  \"Date\",\n  \"ETag\",\n  \"Expires\",\n  \"If-Match\",\n  \"If-Modified-Since\",\n  \"If-None-Match\",\n  \"If-Unmodified-Since\",\n  \"Last-Modified\",\n  \"Pragma\",\n  \"Request-Id\",\n  \"Retry-After\",\n  \"Server\",\n  \"Transfer-Encoding\",\n  \"User-Agent\",\n  \"WWW-Authenticate\",\n];\n\nconst defaultAllowedQueryParameters: string[] = [\"api-version\"];\n\n/**\n * @internal\n */\nexport class Sanitizer {\n  private allowedHeaderNames: Set<string>;\n  private allowedQueryParameters: Set<string>;\n\n  constructor({\n    additionalAllowedHeaderNames: allowedHeaderNames = [],\n    additionalAllowedQueryParameters: allowedQueryParameters = [],\n  }: SanitizerOptions = {}) {\n    allowedHeaderNames = defaultAllowedHeaderNames.concat(allowedHeaderNames);\n    allowedQueryParameters = defaultAllowedQueryParameters.concat(allowedQueryParameters);\n\n    this.allowedHeaderNames = new Set(allowedHeaderNames.map((n) => n.toLowerCase()));\n    this.allowedQueryParameters = new Set(allowedQueryParameters.map((p) => p.toLowerCase()));\n  }\n\n  public sanitize(obj: unknown): string {\n    const seen = new Set<unknown>();\n    return JSON.stringify(\n      obj,\n      (key: string, value: unknown) => {\n        // Ensure Errors include their interesting non-enumerable members\n        if (value instanceof Error) {\n          return {\n            ...value,\n            name: value.name,\n            message: value.message,\n          };\n        }\n\n        if (key === \"headers\") {\n          return this.sanitizeHeaders(value as UnknownObject);\n        } else if (key === \"url\") {\n          return this.sanitizeUrl(value as string);\n        } else if (key === \"query\") {\n          return this.sanitizeQuery(value as UnknownObject);\n        } else if (key === \"body\") {\n          // Don't log the request body\n          return undefined;\n        } else if (key === \"response\") {\n          // Don't log response again\n          return undefined;\n        } else if (key === \"operationSpec\") {\n          // When using sendOperationRequest, the request carries a massive\n          // field with the autorest spec. No need to log it.\n          return undefined;\n        } else if (Array.isArray(value) || isObject(value)) {\n          if (seen.has(value)) {\n            return \"[Circular]\";\n          }\n          seen.add(value);\n        }\n\n        return value;\n      },\n      2,\n    );\n  }\n\n  public sanitizeUrl(value: string): string {\n    if (typeof value !== \"string\" || value === null || value === \"\") {\n      return value;\n    }\n\n    const url = new URL(value);\n\n    if (!url.search) {\n      return value;\n    }\n\n    for (const [key] of url.searchParams) {\n      if (!this.allowedQueryParameters.has(key.toLowerCase())) {\n        url.searchParams.set(key, RedactedString);\n      }\n    }\n\n    return url.toString();\n  }\n\n  private sanitizeHeaders(obj: UnknownObject): UnknownObject {\n    const sanitized: UnknownObject = {};\n    for (const key of Object.keys(obj)) {\n      if (this.allowedHeaderNames.has(key.toLowerCase())) {\n        sanitized[key] = obj[key];\n      } else {\n        sanitized[key] = RedactedString;\n      }\n    }\n    return sanitized;\n  }\n\n  private sanitizeQuery(value: UnknownObject): UnknownObject {\n    if (typeof value !== \"object\" || value === null) {\n      return value;\n    }\n\n    const sanitized: UnknownObject = {};\n\n    for (const k of Object.keys(value)) {\n      if (this.allowedQueryParameters.has(k.toLowerCase())) {\n        sanitized[k] = value[k];\n      } else {\n        sanitized[k] = RedactedString;\n      }\n    }\n\n    return sanitized;\n  }\n}\n", "// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\n\nimport type { Debugger } from \"@azure/logger\";\nimport type { PipelineRequest, PipelineResponse, SendRequest } from \"../interfaces.js\";\nimport type { PipelinePolicy } from \"../pipeline.js\";\nimport { logger as coreLogger } from \"../log.js\";\nimport { Sanitizer } from \"../util/sanitizer.js\";\n\n/**\n * The programmatic identifier of the logPolicy.\n */\nexport const logPolicyName = \"logPolicy\";\n\n/**\n * Options to configure the logPolicy.\n */\nexport interface LogPolicyOptions {\n  /**\n   * Header names whose values will be logged when logging is enabled.\n   * Defaults include a list of well-known safe headers. Any headers\n   * specified in this field will be added to that list.  Any other values will\n   * be written to logs as \"REDACTED\".\n   */\n  additionalAllowedHeaderNames?: string[];\n\n  /**\n   * Query string names whose values will be logged when logging is enabled. By default no\n   * query string values are logged.\n   */\n  additionalAllowedQueryParameters?: string[];\n\n  /**\n   * The log function to use for writing pipeline logs.\n   * Defaults to core-http's built-in logger.\n   * Compatible with the `debug` library.\n   */\n  logger?: Debugger;\n}\n\n/**\n * A policy that logs all requests and responses.\n * @param options - Options to configure logPolicy.\n */\nexport function logPolicy(options: LogPolicyOptions = {}): PipelinePolicy {\n  const logger = options.logger ?? coreLogger.info;\n  const sanitizer = new Sanitizer({\n    additionalAllowedHeaderNames: options.additionalAllowedHeaderNames,\n    additionalAllowedQueryParameters: options.additionalAllowedQueryParameters,\n  });\n  return {\n    name: logPolicyName,\n    async sendRequest(request: PipelineRequest, next: SendRequest): Promise<PipelineResponse> {\n      if (!logger.enabled) {\n        return next(request);\n      }\n\n      logger(`Request: ${sanitizer.sanitize(request)}`);\n\n      const response = await next(request);\n\n      logger(`Response status code: ${response.status}`);\n      logger(`Headers: ${sanitizer.sanitize(response.headers)}`);\n\n      return response;\n    },\n  };\n}\n", "// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\n\nimport type { PipelineRequest, PipelineResponse, SendRequest } from \"../interfaces.js\";\nimport type { PipelinePolicy } from \"../pipeline.js\";\n\n/**\n * The programmatic identifier of the redirectPolicy.\n */\nexport const redirectPolicyName = \"redirectPolicy\";\n\n/**\n * Methods that are allowed to follow redirects 301 and 302\n */\nconst allowedRedirect = [\"GET\", \"HEAD\"];\n\n/**\n * Options for how redirect responses are handled.\n */\nexport interface RedirectPolicyOptions {\n  /**\n   * The maximum number of times the redirect URL will be tried before\n   * failing.  Defaults to 20.\n   */\n  maxRetries?: number;\n}\n\n/**\n * A policy to follow Location headers from the server in order\n * to support server-side redirection.\n * In the browser, this policy is not used.\n * @param options - Options to control policy behavior.\n */\nexport function redirectPolicy(options: RedirectPolicyOptions = {}): PipelinePolicy {\n  const { maxRetries = 20 } = options;\n  return {\n    name: redirectPolicyName,\n    async sendRequest(request: PipelineRequest, next: SendRequest): Promise<PipelineResponse> {\n      const response = await next(request);\n      return handleRedirect(next, response, maxRetries);\n    },\n  };\n}\n\nasync function handleRedirect(\n  next: SendRequest,\n  response: PipelineResponse,\n  maxRetries: number,\n  currentRetries: number = 0,\n): Promise<PipelineResponse> {\n  const { request, status, headers } = response;\n  const locationHeader = headers.get(\"location\");\n  if (\n    locationHeader &&\n    (status === 300 ||\n      (status === 301 && allowedRedirect.includes(request.method)) ||\n      (status === 302 && allowedRedirect.includes(request.method)) ||\n      (status === 303 && request.method === \"POST\") ||\n      status === 307) &&\n    currentRetries < maxRetries\n  ) {\n    const url = new URL(locationHeader, request.url);\n    request.url = url.toString();\n\n    // POST request with Status code 303 should be converted into a\n    // redirected GET request if the redirect url is present in the location header\n    if (status === 303) {\n      request.method = \"GET\";\n      request.headers.delete(\"Content-Length\");\n      delete request.body;\n    }\n\n    request.headers.delete(\"Authorization\");\n\n    const res = await next(request);\n    return handleRedirect(next, res, maxRetries, currentRetries + 1);\n  }\n\n  return response;\n}\n", "// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\n\n/**\n * @internal\n */\nexport function getHeaderName(): string {\n  return \"x-ms-useragent\";\n}\n\ninterface BrowserBrand {\n  brand: string;\n  version: string;\n}\n\ninterface NavigatorEx extends Navigator {\n  userAgentData?: {\n    brands: BrowserBrand[];\n    mobile: boolean;\n    platform?: string;\n    getHighEntropyValues: (hints: string[]) => Promise<{\n      architecture: string;\n      bitness: string;\n      brands: BrowserBrand[];\n      formFactor: string;\n      fullVersionList: BrowserBrand[];\n      mobile: boolean;\n      model: string;\n      platform: string;\n      platformVersion: string;\n      wow64: boolean;\n    }>;\n  };\n}\n\ndeclare const globalThis: {\n  navigator?: NavigatorEx;\n  EdgeRuntime?: unknown;\n};\n\nfunction getBrowserInfo(userAgent: string): BrowserBrand | undefined {\n  const browserRegexes = [\n    { name: \"Firefox\", regex: /Firefox\\/([\\d.]+)/ },\n    { name: \"Safari\", regex: /Version\\/([\\d.]+).*Safari/ },\n  ];\n\n  for (const browser of browserRegexes) {\n    const match = userAgent.match(browser.regex);\n    if (match) {\n      return { brand: browser.name, version: match[1] };\n    }\n  }\n\n  return undefined;\n}\n\nfunction getBrandVersionString(brands: BrowserBrand[]): BrowserBrand | undefined {\n  const brandOrder = [\"Google Chrome\", \"Microsoft Edge\", \"Opera\", \"Brave\", \"Chromium\"];\n  for (const brand of brandOrder) {\n    const foundBrand = brands.find((b) => b.brand === brand);\n    if (foundBrand) {\n      return foundBrand;\n    }\n  }\n  return undefined;\n}\n\n/**\n * @internal\n */\nexport async function setPlatformSpecificData(map: Map<string, string>): Promise<void> {\n  const localNavigator = globalThis.navigator as NavigatorEx;\n  let osPlatform = \"unknown\";\n  if (localNavigator?.userAgentData) {\n    const entropyValues = await localNavigator.userAgentData.getHighEntropyValues([\n      \"architecture\",\n      \"platformVersion\",\n    ]);\n    osPlatform = `${entropyValues.architecture}-${entropyValues.platform}-${entropyValues.platformVersion}`;\n\n    // Get the brand and version\n    const brand = getBrandVersionString(localNavigator.userAgentData.brands);\n    if (brand) {\n      map.set(brand.brand, brand.version);\n    }\n  } else if (localNavigator?.platform) {\n    osPlatform = localNavigator.platform;\n    const brand = getBrowserInfo(localNavigator.userAgent);\n    if (brand) {\n      map.set(brand.brand, brand.version);\n    }\n  } else if (typeof globalThis.EdgeRuntime === \"string\") {\n    map.set(\"EdgeRuntime\", globalThis.EdgeRuntime);\n  }\n\n  map.set(\"OS\", osPlatform);\n}\n", "// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\n\nexport const SDK_VERSION: string = \"1.19.1\";\n\nexport const DEFAULT_RETRY_POLICY_COUNT = 3;\n", "// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\n\nimport { getHeaderName, setPlatformSpecificData } from \"./userAgentPlatform.js\";\nimport { SDK_VERSION } from \"../constants.js\";\n\nfunction getUserAgentString(telemetryInfo: Map<string, string>): string {\n  const parts: string[] = [];\n  for (const [key, value] of telemetryInfo) {\n    const token = value ? `${key}/${value}` : key;\n    parts.push(token);\n  }\n  return parts.join(\" \");\n}\n\n/**\n * @internal\n */\nexport function getUserAgentHeaderName(): string {\n  return getHeaderName();\n}\n\n/**\n * @internal\n */\nexport async function getUserAgentValue(prefix?: string): Promise<string> {\n  const runtimeInfo = new Map<string, string>();\n  runtimeInfo.set(\"core-rest-pipeline\", SDK_VERSION);\n  await setPlatformSpecificData(runtimeInfo);\n  const defaultAgent = getUserAgentString(runtimeInfo);\n  const userAgentValue = prefix ? `${prefix} ${defaultAgent}` : defaultAgent;\n  return userAgentValue;\n}\n", "// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\n\nimport type { PipelineRequest, PipelineResponse, SendRequest } from \"../interfaces.js\";\nimport type { PipelinePolicy } from \"../pipeline.js\";\nimport { getUserAgentHeaderName, getUserAgentValue } from \"../util/userAgent.js\";\n\nconst UserAgentHeaderName = getUserAgentHeaderName();\n\n/**\n * The programmatic identifier of the userAgentPolicy.\n */\nexport const userAgentPolicyName = \"userAgentPolicy\";\n\n/**\n * Options for adding user agent details to outgoing requests.\n */\nexport interface UserAgentPolicyOptions {\n  /**\n   * String prefix to add to the user agent for outgoing requests.\n   * Defaults to an empty string.\n   */\n  userAgentPrefix?: string;\n}\n\n/**\n * A policy that sets the User-Agent header (or equivalent) to reflect\n * the library version.\n * @param options - Options to customize the user agent value.\n */\nexport function userAgentPolicy(options: UserAgentPolicyOptions = {}): PipelinePolicy {\n  const userAgentValue = getUserAgentValue(options.userAgentPrefix);\n  return {\n    name: userAgentPolicyName,\n    async sendRequest(request: PipelineRequest, next: SendRequest): Promise<PipelineResponse> {\n      if (!request.headers.has(UserAgentHeaderName)) {\n        request.headers.set(UserAgentHeaderName, await userAgentValue);\n      }\n      return next(request);\n    },\n  };\n}\n", "// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\n\nexport function isNodeReadableStream(x: unknown): x is NodeJS.ReadableStream {\n  return Boolean(x && typeof (x as NodeJS.ReadableStream)[\"pipe\"] === \"function\");\n}\n\nexport function isWebReadableStream(x: unknown): x is ReadableStream {\n  return Boolean(\n    x &&\n      typeof (x as ReadableStream).getReader === \"function\" &&\n      typeof (x as ReadableStream).tee === \"function\",\n  );\n}\n\nexport function isReadableStream(x: unknown): x is ReadableStream | NodeJS.ReadableStream {\n  return isNodeReadableStream(x) || isWebReadableStream(x);\n}\n\nexport function isBlob(x: unknown): x is Blob {\n  return typeof (x as Blob).stream === \"function\";\n}\n", "// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\n\nimport { isNodeLike } from \"@azure/core-util\";\nimport { isNodeReadableStream } from \"./typeGuards.js\";\n\n/**\n * Options passed into createFile specifying metadata about the file.\n */\nexport interface CreateFileOptions {\n  /**\n   * The MIME type of the file.\n   */\n  type?: string;\n\n  /**\n   * Last modified time of the file as a UNIX timestamp.\n   * This will default to the current date.\n   */\n  lastModified?: number;\n\n  /**\n   * relative path of this file when uploading a directory.\n   */\n  webkitRelativePath?: string;\n}\n\n/**\n * Extra options for createFile when a stream is being passed in.\n */\nexport interface CreateFileFromStreamOptions extends CreateFileOptions {\n  /**\n   * Size of the file represented by the stream in bytes.\n   *\n   * This will be used by the pipeline when calculating the Content-Length header\n   * for the overall request.\n   */\n  size?: number;\n}\n\nconst unimplementedMethods = {\n  arrayBuffer: () => {\n    throw new Error(\"Not implemented\");\n  },\n  bytes: () => {\n    throw new Error(\"Not implemented\");\n  },\n  slice: () => {\n    throw new Error(\"Not implemented\");\n  },\n  text: () => {\n    throw new Error(\"Not implemented\");\n  },\n};\n\n/**\n * Private symbol used as key on objects created using createFile containing the\n * original source of the file object.\n *\n * This is used in Node to access the original Node stream without using Blob#stream, which\n * returns a web stream. This is done to avoid a couple of bugs to do with Blob#stream and\n * Readable#to/fromWeb in Node versions we support:\n * - https://github.com/nodejs/node/issues/42694 (fixed in Node 18.14)\n * - https://github.com/nodejs/node/issues/48916 (fixed in Node 20.6)\n *\n * Once these versions are no longer supported, we may be able to stop doing this.\n *\n * @internal\n */\nconst rawContent: unique symbol = Symbol(\"rawContent\");\n\n/**\n * Type signature of a blob-like object with a raw content property.\n */\ninterface RawContent {\n  [rawContent](): Uint8Array | NodeJS.ReadableStream | ReadableStream<Uint8Array>;\n}\n\nfunction hasRawContent(x: unknown): x is RawContent {\n  return typeof (x as RawContent)[rawContent] === \"function\";\n}\n\n/**\n * Extract the raw content from a given blob-like object. If the input was created using createFile\n * or createFileFromStream, the exact content passed into createFile/createFileFromStream will be used.\n * For true instances of Blob and File, returns the blob's content as a Web ReadableStream<Uint8Array>.\n *\n * @internal\n */\nexport function getRawContent(\n  blob: Blob,\n): NodeJS.ReadableStream | ReadableStream<Uint8Array> | Uint8Array {\n  if (hasRawContent(blob)) {\n    return blob[rawContent]();\n  } else {\n    return blob.stream();\n  }\n}\n\n/**\n * Create an object that implements the File interface. This object is intended to be\n * passed into RequestBodyType.formData, and is not guaranteed to work as expected in\n * other situations.\n *\n * Use this function to:\n * - Create a File object for use in RequestBodyType.formData in environments where the\n *   global File object is unavailable.\n * - Create a File-like object from a readable stream without reading the stream into memory.\n *\n * @param stream - the content of the file as a callback returning a stream. When a File object made using createFile is\n *                  passed in a request's form data map, the stream will not be read into memory\n *                  and instead will be streamed when the request is made. In the event of a retry, the\n *                  stream needs to be read again, so this callback SHOULD return a fresh stream if possible.\n * @param name - the name of the file.\n * @param options - optional metadata about the file, e.g. file name, file size, MIME type.\n */\nexport function createFileFromStream(\n  stream: () => ReadableStream<Uint8Array> | NodeJS.ReadableStream,\n  name: string,\n  options: CreateFileFromStreamOptions = {},\n): File {\n  return {\n    ...unimplementedMethods,\n    type: options.type ?? \"\",\n    lastModified: options.lastModified ?? new Date().getTime(),\n    webkitRelativePath: options.webkitRelativePath ?? \"\",\n    size: options.size ?? -1,\n    name,\n    stream: () => {\n      const s = stream();\n      if (isNodeReadableStream(s)) {\n        throw new Error(\n          \"Not supported: a Node stream was provided as input to createFileFromStream.\",\n        );\n      }\n\n      return s;\n    },\n    [rawContent]: stream,\n  } as File & RawContent;\n}\n\n/**\n * Create an object that implements the File interface. This object is intended to be\n * passed into RequestBodyType.formData, and is not guaranteed to work as expected in\n * other situations.\n *\n * Use this function create a File object for use in RequestBodyType.formData in environments where the global File object is unavailable.\n *\n * @param content - the content of the file as a Uint8Array in memory.\n * @param name - the name of the file.\n * @param options - optional metadata about the file, e.g. file name, file size, MIME type.\n */\nexport function createFile(\n  content: Uint8Array,\n  name: string,\n  options: CreateFileOptions = {},\n): File {\n  if (isNodeLike) {\n    return {\n      ...unimplementedMethods,\n      type: options.type ?? \"\",\n      lastModified: options.lastModified ?? new Date().getTime(),\n      webkitRelativePath: options.webkitRelativePath ?? \"\",\n      size: content.byteLength,\n      name,\n      arrayBuffer: async () => content.buffer,\n      stream: () => new Blob([content]).stream(),\n      [rawContent]: () => content,\n    } as File & RawContent;\n  } else {\n    return new File([content], name, options);\n  }\n}\n", "// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\n\nimport { getRawContent } from \"./file.js\";\nimport { isNodeReadableStream, isWebReadableStream } from \"./typeGuards.js\";\n\n/**\n * Drain the content of the given ReadableStream into a Blob.\n * The blob's content may end up in memory or on disk dependent on size.\n */\nfunction drain(stream: ReadableStream<Uint8Array>): Promise<Blob> {\n  return new Response(stream).blob();\n}\n\nasync function toBlobPart(\n  source: ReadableStream<Uint8Array> | Blob | Uint8Array,\n): Promise<BlobPart> {\n  if (source instanceof Blob || source instanceof Uint8Array) {\n    return source;\n  }\n\n  if (isWebReadableStream(source)) {\n    return drain(source);\n  }\n\n  // If it's not a true Blob, and it's not a Uint8Array, we can assume the source\n  // is a fake File created by createFileFromStream and we can get the original stream\n  // using getRawContent.\n  const rawContent = getRawContent(source);\n\n  // Shouldn't happen but guard for it anyway\n  if (isNodeReadableStream(rawContent)) {\n    throw new Error(\n      \"Encountered unexpected type. In the browser, `concat` supports Web ReadableStream, Blob, Uint8Array, and files created using `createFile` only.\",\n    );\n  }\n\n  return toBlobPart(rawContent);\n}\n\n/**\n * Accepted binary data types for concat\n *\n * @internal\n */\ntype ConcatSource = ReadableStream<Uint8Array> | Blob | Uint8Array;\n\n/**\n * Utility function that concatenates a set of binary inputs into one combined output.\n *\n * @param sources - array of sources for the concatenation\n * @returns - in Node, a (() =\\> NodeJS.ReadableStream) which, when read, produces a concatenation of all the inputs.\n *           In browser, returns a `Blob` representing all the concatenated inputs.\n *\n * @internal\n */\nexport async function concat(\n  sources: (ConcatSource | (() => ConcatSource))[],\n): Promise<(() => NodeJS.ReadableStream) | Blob> {\n  const parts = [];\n  for (const source of sources) {\n    parts.push(await toBlobPart(typeof source === \"function\" ? source() : source));\n  }\n\n  return new Blob(parts);\n}\n", "// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\n\nexport * from \"./concat.common.js\";\n", "// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\n\nimport { randomUUID, stringToUint8Array } from \"@azure/core-util\";\nimport type { BodyPart, HttpHeaders, PipelineRequest, PipelineResponse } from \"../interfaces.js\";\nimport type { PipelinePolicy } from \"../pipeline.js\";\nimport { concat } from \"../util/concat.js\";\nimport { isBlob } from \"../util/typeGuards.js\";\n\nfunction generateBoundary(): string {\n  return `----AzSDKFormBoundary${randomUUID()}`;\n}\n\nfunction encodeHeaders(headers: HttpHeaders): string {\n  let result = \"\";\n  for (const [key, value] of headers) {\n    result += `${key}: ${value}\\r\\n`;\n  }\n  return result;\n}\n\nfunction getLength(\n  source:\n    | (() => ReadableStream<Uint8Array>)\n    | (() => NodeJS.ReadableStream)\n    | Uint8Array\n    | Blob\n    | ReadableStream\n    | NodeJS.ReadableStream,\n): number | undefined {\n  if (source instanceof Uint8Array) {\n    return source.byteLength;\n  } else if (isBlob(source)) {\n    // if was created using createFile then -1 means we have an unknown size\n    return source.size === -1 ? undefined : source.size;\n  } else {\n    return undefined;\n  }\n}\n\nfunction getTotalLength(\n  sources: (\n    | (() => ReadableStream<Uint8Array>)\n    | (() => NodeJS.ReadableStream)\n    | Uint8Array\n    | Blob\n    | ReadableStream\n    | NodeJS.ReadableStream\n  )[],\n): number | undefined {\n  let total = 0;\n  for (const source of sources) {\n    const partLength = getLength(source);\n    if (partLength === undefined) {\n      return undefined;\n    } else {\n      total += partLength;\n    }\n  }\n  return total;\n}\n\nasync function buildRequestBody(\n  request: PipelineRequest,\n  parts: BodyPart[],\n  boundary: string,\n): Promise<void> {\n  const sources = [\n    stringToUint8Array(`--${boundary}`, \"utf-8\"),\n    ...parts.flatMap((part) => [\n      stringToUint8Array(\"\\r\\n\", \"utf-8\"),\n      stringToUint8Array(encodeHeaders(part.headers), \"utf-8\"),\n      stringToUint8Array(\"\\r\\n\", \"utf-8\"),\n      part.body,\n      stringToUint8Array(`\\r\\n--${boundary}`, \"utf-8\"),\n    ]),\n    stringToUint8Array(\"--\\r\\n\\r\\n\", \"utf-8\"),\n  ];\n\n  const contentLength = getTotalLength(sources);\n  if (contentLength) {\n    request.headers.set(\"Content-Length\", contentLength);\n  }\n\n  request.body = await concat(sources);\n}\n\n/**\n * Name of multipart policy\n */\nexport const multipartPolicyName = \"multipartPolicy\";\n\nconst maxBoundaryLength = 70;\nconst validBoundaryCharacters = new Set(\n  `abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789'()+,-./:=?`,\n);\n\nfunction assertValidBoundary(boundary: string): void {\n  if (boundary.length > maxBoundaryLength) {\n    throw new Error(`Multipart boundary \"${boundary}\" exceeds maximum length of 70 characters`);\n  }\n\n  if (Array.from(boundary).some((x) => !validBoundaryCharacters.has(x))) {\n    throw new Error(`Multipart boundary \"${boundary}\" contains invalid characters`);\n  }\n}\n\n/**\n * Pipeline policy for multipart requests\n */\nexport function multipartPolicy(): PipelinePolicy {\n  return {\n    name: multipartPolicyName,\n    async sendRequest(request, next): Promise<PipelineResponse> {\n      if (!request.multipartBody) {\n        return next(request);\n      }\n\n      if (request.body) {\n        throw new Error(\"multipartBody and regular body cannot be set at the same time\");\n      }\n\n      let boundary = request.multipartBody.boundary;\n\n      const contentTypeHeader = request.headers.get(\"Content-Type\") ?? \"multipart/mixed\";\n      const parsedHeader = contentTypeHeader.match(/^(multipart\\/[^ ;]+)(?:; *boundary=(.+))?$/);\n      if (!parsedHeader) {\n        throw new Error(\n          `Got multipart request body, but content-type header was not multipart: ${contentTypeHeader}`,\n        );\n      }\n\n      const [, contentType, parsedBoundary] = parsedHeader;\n      if (parsedBoundary && boundary && parsedBoundary !== boundary) {\n        throw new Error(\n          `Multipart boundary was specified as ${parsedBoundary} in the header, but got ${boundary} in the request body`,\n        );\n      }\n\n      boundary ??= parsedBoundary;\n      if (boundary) {\n        assertValidBoundary(boundary);\n      } else {\n        boundary = generateBoundary();\n      }\n      request.headers.set(\"Content-Type\", `${contentType}; boundary=${boundary}`);\n      await buildRequestBody(request, request.multipartBody.parts, boundary);\n\n      request.multipartBody = undefined;\n\n      return next(request);\n    },\n  };\n}\n", "// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\n\n/*\n * NOTE: When moving this file, please update \"browser\" section in package.json\n */\n\nexport const decompressResponsePolicyName = \"decompressResponsePolicy\";\n\n/**\n * decompressResponsePolicy is not supported in the browser and attempting\n * to use it will raise an error.\n */\nexport function decompressResponsePolicy(): never {\n  throw new Error(\"decompressResponsePolicy is not supported in browser environment\");\n}\n", "// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\n/**\n * This error is thrown when an asynchronous operation has been aborted.\n * Check for this error by testing the `name` that the name property of the\n * error matches `\"AbortError\"`.\n *\n * @example\n * ```ts\n * const controller = new AbortController();\n * controller.abort();\n * try {\n *   doAsyncWork(controller.signal)\n * } catch (e) {\n *   if (e.name === 'AbortError') {\n *     // handle abort error here.\n *   }\n * }\n * ```\n */\nexport class AbortError extends Error {\n  constructor(message?: string) {\n    super(message);\n    this.name = \"AbortError\";\n  }\n}\n", "// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\ndeclare global {\n  interface Event {}\n}\n\nexport { AbortError } from \"./AbortError.js\";\nexport { AbortSignalLike } from \"./AbortSignalLike.js\";\n", "// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\n\nimport { AbortError, type AbortSignalLike } from \"@azure/abort-controller\";\nimport type { PipelineResponse } from \"../interfaces.js\";\n\nconst StandardAbortMessage = \"The operation was aborted.\";\n\n/**\n * A wrapper for setTimeout that resolves a promise after delayInMs milliseconds.\n * @param delayInMs - The number of milliseconds to be delayed.\n * @param value - The value to be resolved with after a timeout of t milliseconds.\n * @param options - The options for delay - currently abort options\n *                  - abortSignal - The abortSignal associated with containing operation.\n *                  - abortErrorMsg - The abort error message associated with containing operation.\n * @returns Resolved promise\n */\nexport function delay<T>(\n  delayInMs: number,\n  value?: T,\n  options?: {\n    abortSignal?: AbortSignalLike;\n    abortErrorMsg?: string;\n  },\n): Promise<T | void> {\n  return new Promise((resolve, reject) => {\n    let timer: ReturnType<typeof setTimeout> | undefined = undefined;\n    let onAborted: (() => void) | undefined = undefined;\n\n    const rejectOnAbort = (): void => {\n      return reject(\n        new AbortError(options?.abortErrorMsg ? options?.abortErrorMsg : StandardAbortMessage),\n      );\n    };\n\n    const removeListeners = (): void => {\n      if (options?.abortSignal && onAborted) {\n        options.abortSignal.removeEventListener(\"abort\", onAborted);\n      }\n    };\n\n    onAborted = (): void => {\n      if (timer) {\n        clearTimeout(timer);\n      }\n      removeListeners();\n      return rejectOnAbort();\n    };\n\n    if (options?.abortSignal && options.abortSignal.aborted) {\n      return rejectOnAbort();\n    }\n\n    timer = setTimeout(() => {\n      removeListeners();\n      resolve(value);\n    }, delayInMs);\n\n    if (options?.abortSignal) {\n      options.abortSignal.addEventListener(\"abort\", onAborted);\n    }\n  });\n}\n\n/**\n * @internal\n * @returns the parsed value or undefined if the parsed value is invalid.\n */\nexport function parseHeaderValueAsNumber(\n  response: PipelineResponse,\n  headerName: string,\n): number | undefined {\n  const value = response.headers.get(headerName);\n  if (!value) return;\n  const valueAsNum = Number(value);\n  if (Number.isNaN(valueAsNum)) return;\n  return valueAsNum;\n}\n", "// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\n\nimport type { PipelineResponse } from \"../index.js\";\nimport { parseHeaderValueAsNumber } from \"../util/helpers.js\";\nimport type { RetryStrategy } from \"./retryStrategy.js\";\n\n/**\n * The header that comes back from Azure services representing\n * the amount of time (minimum) to wait to retry (in seconds or timestamp after which we can retry).\n */\nconst RetryAfterHeader = \"Retry-After\";\n/**\n * The headers that come back from Azure services representing\n * the amount of time (minimum) to wait to retry.\n *\n * \"retry-after-ms\", \"x-ms-retry-after-ms\" : milliseconds\n * \"Retry-After\" : seconds or timestamp\n */\nconst AllRetryAfterHeaders: string[] = [\"retry-after-ms\", \"x-ms-retry-after-ms\", RetryAfterHeader];\n\n/**\n * A response is a throttling retry response if it has a throttling status code (429 or 503),\n * as long as one of the [ \"Retry-After\" or \"retry-after-ms\" or \"x-ms-retry-after-ms\" ] headers has a valid value.\n *\n * Returns the `retryAfterInMs` value if the response is a throttling retry response.\n * If not throttling retry response, returns `undefined`.\n *\n * @internal\n */\nfunction getRetryAfterInMs(response?: PipelineResponse): number | undefined {\n  if (!(response && [429, 503].includes(response.status))) return undefined;\n  try {\n    // Headers: \"retry-after-ms\", \"x-ms-retry-after-ms\", \"Retry-After\"\n    for (const header of AllRetryAfterHeaders) {\n      const retryAfterValue = parseHeaderValueAsNumber(response, header);\n      if (retryAfterValue === 0 || retryAfterValue) {\n        // \"Retry-After\" header ==> seconds\n        // \"retry-after-ms\", \"x-ms-retry-after-ms\" headers ==> milli-seconds\n        const multiplyingFactor = header === RetryAfterHeader ? 1000 : 1;\n        return retryAfterValue * multiplyingFactor; // in milli-seconds\n      }\n    }\n\n    // RetryAfterHeader (\"Retry-After\") has a special case where it might be formatted as a date instead of a number of seconds\n    const retryAfterHeader = response.headers.get(RetryAfterHeader);\n    if (!retryAfterHeader) return;\n\n    const date = Date.parse(retryAfterHeader);\n    const diff = date - Date.now();\n    // negative diff would mean a date in the past, so retry asap with 0 milliseconds\n    return Number.isFinite(diff) ? Math.max(0, diff) : undefined;\n  } catch {\n    return undefined;\n  }\n}\n\n/**\n * A response is a retry response if it has a throttling status code (429 or 503),\n * as long as one of the [ \"Retry-After\" or \"retry-after-ms\" or \"x-ms-retry-after-ms\" ] headers has a valid value.\n */\nexport function isThrottlingRetryResponse(response?: PipelineResponse): boolean {\n  return Number.isFinite(getRetryAfterInMs(response));\n}\n\nexport function throttlingRetryStrategy(): RetryStrategy {\n  return {\n    name: \"throttlingRetryStrategy\",\n    retry({ response }) {\n      const retryAfterInMs = getRetryAfterInMs(response);\n      if (!Number.isFinite(retryAfterInMs)) {\n        return { skipStrategy: true };\n      }\n      return {\n        retryAfterInMs,\n      };\n    },\n  };\n}\n", "// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\n\nimport type { PipelineResponse } from \"../interfaces.js\";\nimport type { RestError } from \"../restError.js\";\nimport { calculateRetryDelay } from \"@azure/core-util\";\nimport type { RetryStrategy } from \"./retryStrategy.js\";\nimport { isThrottlingRetryResponse } from \"./throttlingRetryStrategy.js\";\n\n// intervals are in milliseconds\nconst DEFAULT_CLIENT_RETRY_INTERVAL = 1000;\nconst DEFAULT_CLIENT_MAX_RETRY_INTERVAL = 1000 * 64;\n\n/**\n * A retry strategy that retries with an exponentially increasing delay in these two cases:\n * - When there are errors in the underlying transport layer (e.g. DNS lookup failures).\n * - Or otherwise if the outgoing request fails (408, greater or equal than 500, except for 501 and 505).\n */\nexport function exponentialRetryStrategy(\n  options: {\n    /**\n     * The amount of delay in milliseconds between retry attempts. Defaults to 1000\n     * (1 second.) The delay increases exponentially with each retry up to a maximum\n     * specified by maxRetryDelayInMs.\n     */\n    retryDelayInMs?: number;\n\n    /**\n     * The maximum delay in milliseconds allowed before retrying an operation. Defaults\n     * to 64000 (64 seconds).\n     */\n    maxRetryDelayInMs?: number;\n\n    /**\n     * If true it won't retry if it received a system error.\n     */\n    ignoreSystemErrors?: boolean;\n\n    /**\n     * If true it won't retry if it received a non-fatal HTTP status code.\n     */\n    ignoreHttpStatusCodes?: boolean;\n  } = {},\n): RetryStrategy {\n  const retryInterval = options.retryDelayInMs ?? DEFAULT_CLIENT_RETRY_INTERVAL;\n  const maxRetryInterval = options.maxRetryDelayInMs ?? DEFAULT_CLIENT_MAX_RETRY_INTERVAL;\n\n  return {\n    name: \"exponentialRetryStrategy\",\n    retry({ retryCount, response, responseError }) {\n      const matchedSystemError = isSystemError(responseError);\n      const ignoreSystemErrors = matchedSystemError && options.ignoreSystemErrors;\n\n      const isExponential = isExponentialRetryResponse(response);\n      const ignoreExponentialResponse = isExponential && options.ignoreHttpStatusCodes;\n      const unknownResponse = response && (isThrottlingRetryResponse(response) || !isExponential);\n\n      if (unknownResponse || ignoreExponentialResponse || ignoreSystemErrors) {\n        return { skipStrategy: true };\n      }\n\n      if (responseError && !matchedSystemError && !isExponential) {\n        return { errorToThrow: responseError };\n      }\n\n      return calculateRetryDelay(retryCount, {\n        retryDelayInMs: retryInterval,\n        maxRetryDelayInMs: maxRetryInterval,\n      });\n    },\n  };\n}\n\n/**\n * A response is a retry response if it has status codes:\n * - 408, or\n * - Greater or equal than 500, except for 501 and 505.\n */\nexport function isExponentialRetryResponse(response?: PipelineResponse): boolean {\n  return Boolean(\n    response &&\n      response.status !== undefined &&\n      (response.status >= 500 || response.status === 408) &&\n      response.status !== 501 &&\n      response.status !== 505,\n  );\n}\n\n/**\n * Determines whether an error from a pipeline response was triggered in the network layer.\n */\nexport function isSystemError(err?: RestError): boolean {\n  if (!err) {\n    return false;\n  }\n  return (\n    err.code === \"ETIMEDOUT\" ||\n    err.code === \"ESOCKETTIMEDOUT\" ||\n    err.code === \"ECONNREFUSED\" ||\n    err.code === \"ECONNRESET\" ||\n    err.code === \"ENOENT\" ||\n    err.code === \"ENOTFOUND\"\n  );\n}\n", "// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\n\nimport type { PipelineRequest, PipelineResponse, SendRequest } from \"../interfaces.js\";\nimport type { PipelinePolicy } from \"../pipeline.js\";\nimport { delay } from \"../util/helpers.js\";\nimport { type AzureLogger, createClientLogger } from \"@azure/logger\";\nimport type { RetryStrategy } from \"../retryStrategies/retryStrategy.js\";\nimport type { RestError } from \"../restError.js\";\nimport { AbortError } from \"@azure/abort-controller\";\nimport { DEFAULT_RETRY_POLICY_COUNT } from \"../constants.js\";\n\nconst retryPolicyLogger = createClientLogger(\"core-rest-pipeline retryPolicy\");\n\n/**\n * The programmatic identifier of the retryPolicy.\n */\nconst retryPolicyName = \"retryPolicy\";\n\n/**\n * Options to the {@link retryPolicy}\n */\nexport interface RetryPolicyOptions {\n  /**\n   * Maximum number of retries. If not specified, it will limit to 3 retries.\n   */\n  maxRetries?: number;\n  /**\n   * Logger. If it's not provided, a default logger is used.\n   */\n  logger?: AzureLogger;\n}\n\n/**\n * retryPolicy is a generic policy to enable retrying requests when certain conditions are met\n */\nexport function retryPolicy(\n  strategies: RetryStrategy[],\n  options: RetryPolicyOptions = { maxRetries: DEFAULT_RETRY_POLICY_COUNT },\n): PipelinePolicy {\n  const logger = options.logger || retryPolicyLogger;\n  return {\n    name: retryPolicyName,\n    async sendRequest(request: PipelineRequest, next: SendRequest): Promise<PipelineResponse> {\n      let response: PipelineResponse | undefined;\n      let responseError: RestError | undefined;\n      let retryCount = -1;\n\n      retryRequest: while (true) {\n        retryCount += 1;\n        response = undefined;\n        responseError = undefined;\n\n        try {\n          logger.info(`Retry ${retryCount}: Attempting to send request`, request.requestId);\n          response = await next(request);\n          logger.info(`Retry ${retryCount}: Received a response from request`, request.requestId);\n        } catch (e: any) {\n          logger.error(`Retry ${retryCount}: Received an error from request`, request.requestId);\n\n          // RestErrors are valid targets for the retry strategies.\n          // If none of the retry strategies can work with them, they will be thrown later in this policy.\n          // If the received error is not a RestError, it is immediately thrown.\n          responseError = e as RestError;\n          if (!e || responseError.name !== \"RestError\") {\n            throw e;\n          }\n\n          response = responseError.response;\n        }\n\n        if (request.abortSignal?.aborted) {\n          logger.error(`Retry ${retryCount}: Request aborted.`);\n          const abortError = new AbortError();\n          throw abortError;\n        }\n\n        if (retryCount >= (options.maxRetries ?? DEFAULT_RETRY_POLICY_COUNT)) {\n          logger.info(\n            `Retry ${retryCount}: Maximum retries reached. Returning the last received response, or throwing the last received error.`,\n          );\n          if (responseError) {\n            throw responseError;\n          } else if (response) {\n            return response;\n          } else {\n            throw new Error(\"Maximum retries reached with no response or error to throw\");\n          }\n        }\n\n        logger.info(`Retry ${retryCount}: Processing ${strategies.length} retry strategies.`);\n\n        strategiesLoop: for (const strategy of strategies) {\n          const strategyLogger = strategy.logger || retryPolicyLogger;\n          strategyLogger.info(`Retry ${retryCount}: Processing retry strategy ${strategy.name}.`);\n\n          const modifiers = strategy.retry({\n            retryCount,\n            response,\n            responseError,\n          });\n\n          if (modifiers.skipStrategy) {\n            strategyLogger.info(`Retry ${retryCount}: Skipped.`);\n            continue strategiesLoop;\n          }\n\n          const { errorToThrow, retryAfterInMs, redirectTo } = modifiers;\n\n          if (errorToThrow) {\n            strategyLogger.error(\n              `Retry ${retryCount}: Retry strategy ${strategy.name} throws error:`,\n              errorToThrow,\n            );\n            throw errorToThrow;\n          }\n\n          if (retryAfterInMs || retryAfterInMs === 0) {\n            strategyLogger.info(\n              `Retry ${retryCount}: Retry strategy ${strategy.name} retries after ${retryAfterInMs}`,\n            );\n            await delay(retryAfterInMs, undefined, { abortSignal: request.abortSignal });\n            continue retryRequest;\n          }\n\n          if (redirectTo) {\n            strategyLogger.info(\n              `Retry ${retryCount}: Retry strategy ${strategy.name} redirects to ${redirectTo}`,\n            );\n            request.url = redirectTo;\n            continue retryRequest;\n          }\n        }\n\n        if (responseError) {\n          logger.info(\n            `None of the retry strategies could work with the received error. Throwing it.`,\n          );\n          throw responseError;\n        }\n        if (response) {\n          logger.info(\n            `None of the retry strategies could work with the received response. Returning it.`,\n          );\n          return response;\n        }\n\n        // If all the retries skip and there's no response,\n        // we're still in the retry loop, so a new request will be sent\n        // until `maxRetries` is reached.\n      }\n    },\n  };\n}\n", "// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\n\nimport type { PipelineRetryOptions } from \"../interfaces.js\";\nimport type { PipelinePolicy } from \"../pipeline.js\";\nimport { exponentialRetryStrategy } from \"../retryStrategies/exponentialRetryStrategy.js\";\nimport { throttlingRetryStrategy } from \"../retryStrategies/throttlingRetryStrategy.js\";\nimport { retryPolicy } from \"./retryPolicy.js\";\nimport { DEFAULT_RETRY_POLICY_COUNT } from \"../constants.js\";\n\n/**\n * Name of the {@link defaultRetryPolicy}\n */\nexport const defaultRetryPolicyName = \"defaultRetryPolicy\";\n\n/**\n * Options that control how to retry failed requests.\n */\nexport interface DefaultRetryPolicyOptions extends PipelineRetryOptions {}\n\n/**\n * A policy that retries according to three strategies:\n * - When the server sends a 429 response with a Retry-After header.\n * - When there are errors in the underlying transport layer (e.g. DNS lookup failures).\n * - Or otherwise if the outgoing request fails, it will retry with an exponentially increasing delay.\n */\nexport function defaultRetryPolicy(options: DefaultRetryPolicyOptions = {}): PipelinePolicy {\n  return {\n    name: defaultRetryPolicyName,\n    sendRequest: retryPolicy([throttlingRetryStrategy(), exponentialRetryStrategy(options)], {\n      maxRetries: options.maxRetries ?? DEFAULT_RETRY_POLICY_COUNT,\n    }).sendRequest,\n  };\n}\n", "// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\n\nimport type { HttpHeaders, RawHttpHeaders, RawHttpHeadersInput } from \"./interfaces.js\";\n\ninterface HeaderEntry {\n  name: string;\n  value: string;\n}\n\nfunction normalizeName(name: string): string {\n  return name.toLowerCase();\n}\n\nfunction* headerIterator(map: Map<string, HeaderEntry>): IterableIterator<[string, string]> {\n  for (const entry of map.values()) {\n    yield [entry.name, entry.value];\n  }\n}\n\nclass HttpHeadersImpl implements HttpHeaders {\n  private readonly _headersMap: Map<string, HeaderEntry>;\n\n  constructor(rawHeaders?: RawHttpHeaders | RawHttpHeadersInput) {\n    this._headersMap = new Map<string, HeaderEntry>();\n    if (rawHeaders) {\n      for (const headerName of Object.keys(rawHeaders)) {\n        this.set(headerName, rawHeaders[headerName]);\n      }\n    }\n  }\n\n  /**\n   * Set a header in this collection with the provided name and value. The name is\n   * case-insensitive.\n   * @param name - The name of the header to set. This value is case-insensitive.\n   * @param value - The value of the header to set.\n   */\n  public set(name: string, value: string | number | boolean): void {\n    this._headersMap.set(normalizeName(name), { name, value: String(value).trim() });\n  }\n\n  /**\n   * Get the header value for the provided header name, or undefined if no header exists in this\n   * collection with the provided name.\n   * @param name - The name of the header. This value is case-insensitive.\n   */\n  public get(name: string): string | undefined {\n    return this._headersMap.get(normalizeName(name))?.value;\n  }\n\n  /**\n   * Get whether or not this header collection contains a header entry for the provided header name.\n   * @param name - The name of the header to set. This value is case-insensitive.\n   */\n  public has(name: string): boolean {\n    return this._headersMap.has(normalizeName(name));\n  }\n\n  /**\n   * Remove the header with the provided headerName.\n   * @param name - The name of the header to remove.\n   */\n  public delete(name: string): void {\n    this._headersMap.delete(normalizeName(name));\n  }\n\n  /**\n   * Get the JSON object representation of this HTTP header collection.\n   */\n  public toJSON(options: { preserveCase?: boolean } = {}): RawHttpHeaders {\n    const result: RawHttpHeaders = {};\n    if (options.preserveCase) {\n      for (const entry of this._headersMap.values()) {\n        result[entry.name] = entry.value;\n      }\n    } else {\n      for (const [normalizedName, entry] of this._headersMap) {\n        result[normalizedName] = entry.value;\n      }\n    }\n\n    return result;\n  }\n\n  /**\n   * Get the string representation of this HTTP header collection.\n   */\n  public toString(): string {\n    return JSON.stringify(this.toJSON({ preserveCase: true }));\n  }\n\n  /**\n   * Iterate over tuples of header [name, value] pairs.\n   */\n  [Symbol.iterator](): Iterator<[string, string]> {\n    return headerIterator(this._headersMap);\n  }\n}\n\n/**\n * Creates an object that satisfies the `HttpHeaders` interface.\n * @param rawHeaders - A simple object representing initial headers\n */\nexport function createHttpHeaders(rawHeaders?: RawHttpHeadersInput): HttpHeaders {\n  return new HttpHeadersImpl(rawHeaders);\n}\n", "// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\n\nimport { isNodeLike, stringToUint8Array } from \"@azure/core-util\";\nimport { createHttpHeaders } from \"../httpHeaders.js\";\nimport type {\n  BodyPart,\n  FormDataMap,\n  FormDataValue,\n  PipelineRequest,\n  PipelineResponse,\n  SendRequest,\n} from \"../interfaces.js\";\nimport type { PipelinePolicy } from \"../pipeline.js\";\n\n/**\n * The programmatic identifier of the formDataPolicy.\n */\nexport const formDataPolicyName = \"formDataPolicy\";\n\nfunction formDataToFormDataMap(formData: FormData): FormDataMap {\n  const formDataMap: FormDataMap = {};\n  for (const [key, value] of formData.entries()) {\n    formDataMap[key] ??= [];\n    (formDataMap[key] as FormDataValue[]).push(value);\n  }\n  return formDataMap;\n}\n\n/**\n * A policy that encodes FormData on the request into the body.\n */\nexport function formDataPolicy(): PipelinePolicy {\n  return {\n    name: formDataPolicyName,\n    async sendRequest(request: PipelineRequest, next: SendRequest): Promise<PipelineResponse> {\n      if (isNodeLike && typeof FormData !== \"undefined\" && request.body instanceof FormData) {\n        request.formData = formDataToFormDataMap(request.body);\n        request.body = undefined;\n      }\n\n      if (request.formData) {\n        const contentType = request.headers.get(\"Content-Type\");\n        if (contentType && contentType.indexOf(\"application/x-www-form-urlencoded\") !== -1) {\n          request.body = wwwFormUrlEncode(request.formData);\n        } else {\n          await prepareFormData(request.formData, request);\n        }\n\n        request.formData = undefined;\n      }\n      return next(request);\n    },\n  };\n}\n\nfunction wwwFormUrlEncode(formData: FormDataMap): string {\n  const urlSearchParams = new URLSearchParams();\n  for (const [key, value] of Object.entries(formData)) {\n    if (Array.isArray(value)) {\n      for (const subValue of value) {\n        urlSearchParams.append(key, subValue.toString());\n      }\n    } else {\n      urlSearchParams.append(key, value.toString());\n    }\n  }\n  return urlSearchParams.toString();\n}\n\nasync function prepareFormData(formData: FormDataMap, request: PipelineRequest): Promise<void> {\n  // validate content type (multipart/form-data)\n  const contentType = request.headers.get(\"Content-Type\");\n  if (contentType && !contentType.startsWith(\"multipart/form-data\")) {\n    // content type is specified and is not multipart/form-data. Exit.\n    return;\n  }\n\n  request.headers.set(\"Content-Type\", contentType ?? \"multipart/form-data\");\n\n  // set body to MultipartRequestBody using content from FormDataMap\n  const parts: BodyPart[] = [];\n\n  for (const [fieldName, values] of Object.entries(formData)) {\n    for (const value of Array.isArray(values) ? values : [values]) {\n      if (typeof value === \"string\") {\n        parts.push({\n          headers: createHttpHeaders({\n            \"Content-Disposition\": `form-data; name=\"${fieldName}\"`,\n          }),\n          body: stringToUint8Array(value, \"utf-8\"),\n        });\n      } else if (value === undefined || value === null || typeof value !== \"object\") {\n        throw new Error(\n          `Unexpected value for key ${fieldName}: ${value}. Value should be serialized to string first.`,\n        );\n      } else {\n        // using || instead of ?? here since if value.name is empty we should create a file name\n        const fileName = (value as File).name || \"blob\";\n        const headers = createHttpHeaders();\n        headers.set(\n          \"Content-Disposition\",\n          `form-data; name=\"${fieldName}\"; filename=\"${fileName}\"`,\n        );\n\n        // again, || is used since an empty value.type means the content type is unset\n        headers.set(\"Content-Type\", value.type || \"application/octet-stream\");\n\n        parts.push({\n          headers,\n          body: value,\n        });\n      }\n    }\n  }\n  request.multipartBody = { parts };\n}\n", "// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\n\nexport const proxyPolicyName = \"proxyPolicy\";\nconst errorMessage = \"proxyPolicy is not supported in browser environment\";\n\nexport function getDefaultProxySettings(): never {\n  throw new Error(errorMessage);\n}\n\n/**\n * proxyPolicy is not supported in the browser and attempting\n * to use it will raise an error.\n */\nexport function proxyPolicy(): never {\n  throw new Error(errorMessage);\n}\n\n/**\n * A function to reset the cached agents.\n * proxyPolicy is not supported in the browser and attempting\n * to use it will raise an error.\n * @internal\n */\nexport function resetCachedProxyAgents(): never {\n  throw new Error(errorMessage);\n}\n", "// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\n\nexport * from \"./proxyPolicy.common.js\";\n", "// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\n\nimport type { PipelineRequest, PipelineResponse, SendRequest } from \"../interfaces.js\";\nimport type { PipelinePolicy } from \"../pipeline.js\";\n\n/**\n * The programmatic identifier of the setClientRequestIdPolicy.\n */\nexport const setClientRequestIdPolicyName = \"setClientRequestIdPolicy\";\n\n/**\n * Each PipelineRequest gets a unique id upon creation.\n * This policy passes that unique id along via an HTTP header to enable better\n * telemetry and tracing.\n * @param requestIdHeaderName - The name of the header to pass the request ID to.\n */\nexport function setClientRequestIdPolicy(\n  requestIdHeaderName = \"x-ms-client-request-id\",\n): PipelinePolicy {\n  return {\n    name: setClientRequestIdPolicyName,\n    async sendRequest(request: PipelineRequest, next: SendRequest): Promise<PipelineResponse> {\n      if (!request.headers.has(requestIdHeaderName)) {\n        request.headers.set(requestIdHeaderName, request.requestId);\n      }\n      return next(request);\n    },\n  };\n}\n", "// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\n\nimport type { PipelinePolicy } from \"../pipeline.js\";\nimport type { Agent } from \"../interfaces.js\";\n\n/**\n * Name of the Agent Policy\n */\nexport const agentPolicyName = \"agentPolicy\";\n\n/**\n * Gets a pipeline policy that sets http.agent\n */\nexport function agentPolicy(agent?: Agent): PipelinePolicy {\n  return {\n    name: agentPolicyName,\n    sendRequest: async (req, next) => {\n      // Users may define an agent on the request, honor it over the client level one\n      if (!req.agent) {\n        req.agent = agent;\n      }\n      return next(req);\n    },\n  };\n}\n", "// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\n\nimport type { PipelinePolicy } from \"../pipeline.js\";\nimport type { TlsSettings } from \"../interfaces.js\";\n\n/**\n * Name of the TLS Policy\n */\nexport const tlsPolicyName = \"tlsPolicy\";\n\n/**\n * Gets a pipeline policy that adds the client certificate to the HttpClient agent for authentication.\n */\nexport function tlsPolicy(tlsSettings?: TlsSettings): PipelinePolicy {\n  return {\n    name: tlsPolicyName,\n    sendRequest: async (req, next) => {\n      // Users may define a request tlsSettings, honor those over the client level one\n      if (!req.tlsSettings) {\n        req.tlsSettings = tlsSettings;\n      }\n      return next(req);\n    },\n  };\n}\n", "// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\n\nimport { TracingContext, TracingSpan } from \"./interfaces.js\";\n\n/** @internal */\nexport const knownContextKeys = {\n  span: Symbol.for(\"@azure/core-tracing span\"),\n  namespace: Symbol.for(\"@azure/core-tracing namespace\"),\n};\n\n/**\n * Creates a new {@link TracingContext} with the given options.\n * @param options - A set of known keys that may be set on the context.\n * @returns A new {@link TracingContext} with the given options.\n *\n * @internal\n */\nexport function createTracingContext(options: CreateTracingContextOptions = {}): TracingContext {\n  let context: TracingContext = new TracingContextImpl(options.parentContext);\n  if (options.span) {\n    context = context.setValue(knownContextKeys.span, options.span);\n  }\n  if (options.namespace) {\n    context = context.setValue(knownContextKeys.namespace, options.namespace);\n  }\n  return context;\n}\n\n/** @internal */\nexport class TracingContextImpl implements TracingContext {\n  private _contextMap: Map<symbol, unknown>;\n  constructor(initialContext?: TracingContext) {\n    this._contextMap =\n      initialContext instanceof TracingContextImpl\n        ? new Map<symbol, unknown>(initialContext._contextMap)\n        : new Map();\n  }\n\n  setValue(key: symbol, value: unknown): TracingContext {\n    const newContext = new TracingContextImpl(this);\n    newContext._contextMap.set(key, value);\n    return newContext;\n  }\n\n  getValue(key: symbol): unknown {\n    return this._contextMap.get(key);\n  }\n\n  deleteValue(key: symbol): TracingContext {\n    const newContext = new TracingContextImpl(this);\n    newContext._contextMap.delete(key);\n    return newContext;\n  }\n}\n\n/**\n * Represents a set of items that can be set when creating a new {@link TracingContext}.\n */\nexport interface CreateTracingContextOptions {\n  /** The {@link parentContext} - the newly created context will contain all the values of the parent context unless overridden. */\n  parentContext?: TracingContext;\n  /** An initial span to set on the context. */\n  span?: TracingSpan;\n  /** The namespace to set on any child spans. */\n  namespace?: string;\n}\n", "// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\n\nimport { Instrumenter } from \"./interfaces.js\";\n\n/**\n * Browser-only implementation of the module's state. The browser esm variant will not load the commonjs state, so we do not need to share state between the two.\n */\nexport const state = {\n  instrumenterImplementation: undefined as Instrumenter | undefined,\n};\n", "// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\n\nimport {\n  Instrumenter,\n  InstrumenterSpanOptions,\n  TracingContext,\n  TracingSpan,\n} from \"./interfaces.js\";\n\nimport { createTracingContext } from \"./tracingContext.js\";\nimport { state } from \"./state.js\";\n\nexport function createDefaultTracingSpan(): TracingSpan {\n  return {\n    end: () => {\n      // noop\n    },\n    isRecording: () => false,\n    recordException: () => {\n      // noop\n    },\n    setAttribute: () => {\n      // noop\n    },\n    setStatus: () => {\n      // noop\n    },\n    addEvent: () => {\n      // noop\n    },\n  };\n}\n\nexport function createDefaultInstrumenter(): Instrumenter {\n  return {\n    createRequestHeaders: (): Record<string, string> => {\n      return {};\n    },\n    parseTraceparentHeader: (): TracingContext | undefined => {\n      return undefined;\n    },\n    startSpan: (\n      _name: string,\n      spanOptions: InstrumenterSpanOptions,\n    ): { span: TracingSpan; tracingContext: TracingContext } => {\n      return {\n        span: createDefaultTracingSpan(),\n        tracingContext: createTracingContext({ parentContext: spanOptions.tracingContext }),\n      };\n    },\n    withContext<\n      CallbackArgs extends unknown[],\n      Callback extends (...args: CallbackArgs) => ReturnType<Callback>,\n    >(\n      _context: TracingContext,\n      callback: Callback,\n      ...callbackArgs: CallbackArgs\n    ): ReturnType<Callback> {\n      return callback(...callbackArgs);\n    },\n  };\n}\n\n/**\n * Extends the Azure SDK with support for a given instrumenter implementation.\n *\n * @param instrumenter - The instrumenter implementation to use.\n */\nexport function useInstrumenter(instrumenter: Instrumenter): void {\n  state.instrumenterImplementation = instrumenter;\n}\n\n/**\n * Gets the currently set instrumenter, a No-Op instrumenter by default.\n *\n * @returns The currently set instrumenter\n */\nexport function getInstrumenter(): Instrumenter {\n  if (!state.instrumenterImplementation) {\n    state.instrumenterImplementation = createDefaultInstrumenter();\n  }\n  return state.instrumenterImplementation;\n}\n", "// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\n\nimport {\n  OperationTracingOptions,\n  OptionsWithTracingContext,\n  Resolved,\n  TracingClient,\n  TracingClientOptions,\n  TracingContext,\n  TracingSpan,\n  TracingSpanOptions,\n} from \"./interfaces.js\";\nimport { getInstrumenter } from \"./instrumenter.js\";\nimport { knownContextKeys } from \"./tracingContext.js\";\n\n/**\n * Creates a new tracing client.\n *\n * @param options - Options used to configure the tracing client.\n * @returns - An instance of {@link TracingClient}.\n */\nexport function createTracingClient(options: TracingClientOptions): TracingClient {\n  const { namespace, packageName, packageVersion } = options;\n\n  function startSpan<Options extends { tracingOptions?: OperationTracingOptions }>(\n    name: string,\n    operationOptions?: Options,\n    spanOptions?: TracingSpanOptions,\n  ): {\n    span: TracingSpan;\n    updatedOptions: OptionsWithTracingContext<Options>;\n  } {\n    const startSpanResult = getInstrumenter().startSpan(name, {\n      ...spanOptions,\n      packageName: packageName,\n      packageVersion: packageVersion,\n      tracingContext: operationOptions?.tracingOptions?.tracingContext,\n    });\n    let tracingContext = startSpanResult.tracingContext;\n    const span = startSpanResult.span;\n    if (!tracingContext.getValue(knownContextKeys.namespace)) {\n      tracingContext = tracingContext.setValue(knownContextKeys.namespace, namespace);\n    }\n    span.setAttribute(\"az.namespace\", tracingContext.getValue(knownContextKeys.namespace));\n    const updatedOptions: OptionsWithTracingContext<Options> = Object.assign({}, operationOptions, {\n      tracingOptions: { ...operationOptions?.tracingOptions, tracingContext },\n    });\n\n    return {\n      span,\n      updatedOptions,\n    };\n  }\n\n  async function withSpan<\n    Options extends { tracingOptions?: OperationTracingOptions },\n    Callback extends (\n      updatedOptions: Options,\n      span: Omit<TracingSpan, \"end\">,\n    ) => ReturnType<Callback>,\n  >(\n    name: string,\n    operationOptions: Options,\n    callback: Callback,\n    spanOptions?: TracingSpanOptions,\n  ): Promise<Resolved<ReturnType<Callback>>> {\n    const { span, updatedOptions } = startSpan(name, operationOptions, spanOptions);\n    try {\n      const result = await withContext(updatedOptions.tracingOptions.tracingContext, () =>\n        Promise.resolve(callback(updatedOptions, span)),\n      );\n      span.setStatus({ status: \"success\" });\n      return result as ReturnType<typeof withSpan>;\n    } catch (err: any) {\n      span.setStatus({ status: \"error\", error: err });\n      throw err;\n    } finally {\n      span.end();\n    }\n  }\n\n  function withContext<\n    CallbackArgs extends unknown[],\n    Callback extends (...args: CallbackArgs) => ReturnType<Callback>,\n  >(\n    context: TracingContext,\n    callback: Callback,\n    ...callbackArgs: CallbackArgs\n  ): ReturnType<Callback> {\n    return getInstrumenter().withContext(context, callback, ...callbackArgs);\n  }\n\n  /**\n   * Parses a traceparent header value into a span identifier.\n   *\n   * @param traceparentHeader - The traceparent header to parse.\n   * @returns An implementation-specific identifier for the span.\n   */\n  function parseTraceparentHeader(traceparentHeader: string): TracingContext | undefined {\n    return getInstrumenter().parseTraceparentHeader(traceparentHeader);\n  }\n\n  /**\n   * Creates a set of request headers to propagate tracing information to a backend.\n   *\n   * @param tracingContext - The context containing the span to serialize.\n   * @returns The set of headers to add to a request.\n   */\n  function createRequestHeaders(tracingContext?: TracingContext): Record<string, string> {\n    return getInstrumenter().createRequestHeaders(tracingContext);\n  }\n\n  return {\n    startSpan,\n    withSpan,\n    withContext,\n    parseTraceparentHeader,\n    createRequestHeaders,\n  };\n}\n", "// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\n\nexport {\n  AddEventOptions,\n  Instrumenter,\n  InstrumenterSpanOptions,\n  OperationTracingOptions,\n  OptionsWithTracingContext,\n  Resolved,\n  SpanStatus,\n  SpanStatusError,\n  SpanStatusSuccess,\n  TracingClient,\n  TracingClientOptions,\n  TracingContext,\n  TracingSpan,\n  TracingSpanKind,\n  TracingSpanLink,\n  TracingSpanOptions,\n} from \"./interfaces.js\";\nexport { useInstrumenter } from \"./instrumenter.js\";\nexport { createTracingClient } from \"./tracingClient.js\";\n", "// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\n\nexport const custom = {};\n", "// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\n\nexport * from \"./inspect.common.js\";\n", "// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\n\nimport { isError } from \"@azure/core-util\";\nimport type { PipelineRequest, PipelineResponse } from \"./interfaces.js\";\nimport { custom } from \"./util/inspect.js\";\nimport { Sanitizer } from \"./util/sanitizer.js\";\n\nconst errorSanitizer = new Sanitizer();\n\n/**\n * The options supported by RestError.\n */\nexport interface RestErrorOptions {\n  /**\n   * The code of the error itself (use statics on RestError if possible.)\n   */\n  code?: string;\n  /**\n   * The HTTP status code of the request (if applicable.)\n   */\n  statusCode?: number;\n  /**\n   * The request that was made.\n   */\n  request?: PipelineRequest;\n  /**\n   * The response received (if any.)\n   */\n  response?: PipelineResponse;\n}\n\n/**\n * A custom error type for failed pipeline requests.\n */\nexport class RestError extends Error {\n  /**\n   * Something went wrong when making the request.\n   * This means the actual request failed for some reason,\n   * such as a DNS issue or the connection being lost.\n   */\n  static readonly REQUEST_SEND_ERROR: string = \"REQUEST_SEND_ERROR\";\n  /**\n   * This means that parsing the response from the server failed.\n   * It may have been malformed.\n   */\n  static readonly PARSE_ERROR: string = \"PARSE_ERROR\";\n\n  /**\n   * The code of the error itself (use statics on RestError if possible.)\n   */\n  public code?: string;\n  /**\n   * The HTTP status code of the request (if applicable.)\n   */\n  public statusCode?: number;\n  /**\n   * The request that was made.\n   * This property is non-enumerable.\n   */\n  public request?: PipelineRequest;\n  /**\n   * The response received (if any.)\n   * This property is non-enumerable.\n   */\n  public response?: PipelineResponse;\n  /**\n   * Bonus property set by the throw site.\n   */\n  public details?: unknown;\n\n  constructor(message: string, options: RestErrorOptions = {}) {\n    super(message);\n    this.name = \"RestError\";\n    this.code = options.code;\n    this.statusCode = options.statusCode;\n\n    // The request and response may contain sensitive information in the headers or body.\n    // To help prevent this sensitive information being accidentally logged, the request and response\n    // properties are marked as non-enumerable here. This prevents them showing up in the output of\n    // JSON.stringify and console.log.\n    Object.defineProperty(this, \"request\", { value: options.request, enumerable: false });\n    Object.defineProperty(this, \"response\", { value: options.response, enumerable: false });\n\n    Object.setPrototypeOf(this, RestError.prototype);\n  }\n\n  /**\n   * Logging method for util.inspect in Node\n   */\n  [custom](): string {\n    // Extract non-enumerable properties and add them back. This is OK since in this output the request and\n    // response get sanitized.\n    return `RestError: ${this.message} \\n ${errorSanitizer.sanitize({\n      ...this,\n      request: this.request,\n      response: this.response,\n    })}`;\n  }\n}\n\n/**\n * Typeguard for RestError\n * @param e - Something caught by a catch clause.\n */\nexport function isRestError(e: unknown): e is RestError {\n  if (e instanceof RestError) {\n    return true;\n  }\n  return isError(e) && e.name === \"RestError\";\n}\n", "// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\n\nimport {\n  type TracingClient,\n  type TracingContext,\n  type TracingSpan,\n  createTracingClient,\n} from \"@azure/core-tracing\";\nimport { SDK_VERSION } from \"../constants.js\";\nimport type { PipelineRequest, PipelineResponse, SendRequest } from \"../interfaces.js\";\nimport type { PipelinePolicy } from \"../pipeline.js\";\nimport { getUserAgentValue } from \"../util/userAgent.js\";\nimport { logger } from \"../log.js\";\nimport { getErrorMessage, isError } from \"@azure/core-util\";\nimport { isRestError } from \"../restError.js\";\nimport { Sanitizer } from \"../util/sanitizer.js\";\n\n/**\n * The programmatic identifier of the tracingPolicy.\n */\nexport const tracingPolicyName = \"tracingPolicy\";\n\n/**\n * Options to configure the tracing policy.\n */\nexport interface TracingPolicyOptions {\n  /**\n   * String prefix to add to the user agent logged as metadata\n   * on the generated Span.\n   * Defaults to an empty string.\n   */\n  userAgentPrefix?: string;\n  /**\n   * Query string names whose values will be logged when logging is enabled. By default no\n   * query string values are logged.\n   */\n  additionalAllowedQueryParameters?: string[];\n}\n\n/**\n * A simple policy to create OpenTelemetry Spans for each request made by the pipeline\n * that has SpanOptions with a parent.\n * Requests made without a parent Span will not be recorded.\n * @param options - Options to configure the telemetry logged by the tracing policy.\n */\nexport function tracingPolicy(options: TracingPolicyOptions = {}): PipelinePolicy {\n  const userAgentPromise = getUserAgentValue(options.userAgentPrefix);\n  const sanitizer = new Sanitizer({\n    additionalAllowedQueryParameters: options.additionalAllowedQueryParameters,\n  });\n  const tracingClient = tryCreateTracingClient();\n\n  return {\n    name: tracingPolicyName,\n    async sendRequest(request: PipelineRequest, next: SendRequest): Promise<PipelineResponse> {\n      if (!tracingClient) {\n        return next(request);\n      }\n\n      const userAgent = await userAgentPromise;\n\n      const spanAttributes = {\n        \"http.url\": sanitizer.sanitizeUrl(request.url),\n        \"http.method\": request.method,\n        \"http.user_agent\": userAgent,\n        requestId: request.requestId,\n      };\n      if (userAgent) {\n        spanAttributes[\"http.user_agent\"] = userAgent;\n      }\n\n      const { span, tracingContext } = tryCreateSpan(tracingClient, request, spanAttributes) ?? {};\n\n      if (!span || !tracingContext) {\n        return next(request);\n      }\n\n      try {\n        const response = await tracingClient.withContext(tracingContext, next, request);\n        tryProcessResponse(span, response);\n        return response;\n      } catch (err: any) {\n        tryProcessError(span, err);\n        throw err;\n      }\n    },\n  };\n}\n\nfunction tryCreateTracingClient(): TracingClient | undefined {\n  try {\n    return createTracingClient({\n      namespace: \"\",\n      packageName: \"@azure/core-rest-pipeline\",\n      packageVersion: SDK_VERSION,\n    });\n  } catch (e: unknown) {\n    logger.warning(`Error when creating the TracingClient: ${getErrorMessage(e)}`);\n    return undefined;\n  }\n}\n\nfunction tryCreateSpan(\n  tracingClient: TracingClient,\n  request: PipelineRequest,\n  spanAttributes: Record<string, unknown>,\n): { span: TracingSpan; tracingContext: TracingContext } | undefined {\n  try {\n    // As per spec, we do not need to differentiate between HTTP and HTTPS in span name.\n    const { span, updatedOptions } = tracingClient.startSpan(\n      `HTTP ${request.method}`,\n      { tracingOptions: request.tracingOptions },\n      {\n        spanKind: \"client\",\n        spanAttributes,\n      },\n    );\n\n    // If the span is not recording, don't do any more work.\n    if (!span.isRecording()) {\n      span.end();\n      return undefined;\n    }\n\n    // set headers\n    const headers = tracingClient.createRequestHeaders(\n      updatedOptions.tracingOptions.tracingContext,\n    );\n    for (const [key, value] of Object.entries(headers)) {\n      request.headers.set(key, value);\n    }\n    return { span, tracingContext: updatedOptions.tracingOptions.tracingContext };\n  } catch (e: any) {\n    logger.warning(`Skipping creating a tracing span due to an error: ${getErrorMessage(e)}`);\n    return undefined;\n  }\n}\n\nfunction tryProcessError(span: TracingSpan, error: unknown): void {\n  try {\n    span.setStatus({\n      status: \"error\",\n      error: isError(error) ? error : undefined,\n    });\n    if (isRestError(error) && error.statusCode) {\n      span.setAttribute(\"http.status_code\", error.statusCode);\n    }\n    span.end();\n  } catch (e: any) {\n    logger.warning(`Skipping tracing span processing due to an error: ${getErrorMessage(e)}`);\n  }\n}\n\nfunction tryProcessResponse(span: TracingSpan, response: PipelineResponse): void {\n  try {\n    span.setAttribute(\"http.status_code\", response.status);\n    const serviceRequestId = response.headers.get(\"x-ms-request-id\");\n    if (serviceRequestId) {\n      span.setAttribute(\"serviceRequestId\", serviceRequestId);\n    }\n    // Per semantic conventions, only set the status to error if the status code is 4xx or 5xx.\n    // Otherwise, the status MUST remain unset.\n    // https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status\n    if (response.status >= 400) {\n      span.setStatus({\n        status: \"error\",\n      });\n    }\n    span.end();\n  } catch (e: any) {\n    logger.warning(`Skipping tracing span processing due to an error: ${getErrorMessage(e)}`);\n  }\n}\n", "// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\n\nimport { type LogPolicyOptions, logPolicy } from \"./policies/logPolicy.js\";\nimport { type Pipeline, createEmptyPipeline } from \"./pipeline.js\";\nimport type { Agent, PipelineRetryOptions, ProxySettings, TlsSettings } from \"./interfaces.js\";\nimport { type RedirectPolicyOptions, redirectPolicy } from \"./policies/redirectPolicy.js\";\nimport { type UserAgentPolicyOptions, userAgentPolicy } from \"./policies/userAgentPolicy.js\";\nimport { multipartPolicy, multipartPolicyName } from \"./policies/multipartPolicy.js\";\nimport { decompressResponsePolicy } from \"./policies/decompressResponsePolicy.js\";\nimport { defaultRetryPolicy } from \"./policies/defaultRetryPolicy.js\";\nimport { formDataPolicy } from \"./policies/formDataPolicy.js\";\nimport { isNodeLike } from \"@azure/core-util\";\nimport { proxyPolicy } from \"./policies/proxyPolicy.js\";\nimport { setClientRequestIdPolicy } from \"./policies/setClientRequestIdPolicy.js\";\nimport { agentPolicy } from \"./policies/agentPolicy.js\";\nimport { tlsPolicy } from \"./policies/tlsPolicy.js\";\nimport { tracingPolicy } from \"./policies/tracingPolicy.js\";\n\n/**\n * Defines options that are used to configure the HTTP pipeline for\n * an SDK client.\n */\nexport interface PipelineOptions {\n  /**\n   * Options that control how to retry failed requests.\n   */\n  retryOptions?: PipelineRetryOptions;\n\n  /**\n   * Options to configure a proxy for outgoing requests.\n   */\n  proxyOptions?: ProxySettings;\n\n  /** Options for configuring Agent instance for outgoing requests */\n  agent?: Agent;\n\n  /** Options for configuring TLS authentication */\n  tlsOptions?: TlsSettings;\n\n  /**\n   * Options for how redirect responses are handled.\n   */\n  redirectOptions?: RedirectPolicyOptions;\n\n  /**\n   * Options for adding user agent details to outgoing requests.\n   */\n  userAgentOptions?: UserAgentPolicyOptions;\n\n  /**\n   * Options for setting common telemetry and tracing info to outgoing requests.\n   */\n  telemetryOptions?: TelemetryOptions;\n}\n\n/**\n * Defines options that are used to configure common telemetry and tracing info\n */\nexport interface TelemetryOptions {\n  /**\n   * The name of the header to pass the request ID to.\n   */\n  clientRequestIdHeaderName?: string;\n}\n\n/**\n * Defines options that are used to configure internal options of\n * the HTTP pipeline for an SDK client.\n */\nexport interface InternalPipelineOptions extends PipelineOptions {\n  /**\n   * Options to configure request/response logging.\n   */\n  loggingOptions?: LogPolicyOptions;\n}\n\n/**\n * Create a new pipeline with a default set of customizable policies.\n * @param options - Options to configure a custom pipeline.\n */\nexport function createPipelineFromOptions(options: InternalPipelineOptions): Pipeline {\n  const pipeline = createEmptyPipeline();\n\n  if (isNodeLike) {\n    if (options.agent) {\n      pipeline.addPolicy(agentPolicy(options.agent));\n    }\n    if (options.tlsOptions) {\n      pipeline.addPolicy(tlsPolicy(options.tlsOptions));\n    }\n    pipeline.addPolicy(proxyPolicy(options.proxyOptions));\n    pipeline.addPolicy(decompressResponsePolicy());\n  }\n\n  pipeline.addPolicy(formDataPolicy(), { beforePolicies: [multipartPolicyName] });\n  pipeline.addPolicy(userAgentPolicy(options.userAgentOptions));\n  pipeline.addPolicy(setClientRequestIdPolicy(options.telemetryOptions?.clientRequestIdHeaderName));\n  // The multipart policy is added after policies with no phase, so that\n  // policies can be added between it and formDataPolicy to modify\n  // properties (e.g., making the boundary constant in recorded tests).\n  pipeline.addPolicy(multipartPolicy(), { afterPhase: \"Deserialize\" });\n  pipeline.addPolicy(defaultRetryPolicy(options.retryOptions), { phase: \"Retry\" });\n  pipeline.addPolicy(tracingPolicy({ ...options.userAgentOptions, ...options.loggingOptions }), {\n    afterPhase: \"Retry\",\n  });\n  if (isNodeLike) {\n    // Both XHR and Fetch expect to handle redirects automatically,\n    // so only include this policy when we're in Node.\n    pipeline.addPolicy(redirectPolicy(options.redirectOptions), { afterPhase: \"Retry\" });\n  }\n  pipeline.addPolicy(logPolicy(options.loggingOptions), { afterPhase: \"Sign\" });\n\n  return pipeline;\n}\n", "// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\n\nimport { AbortError } from \"@azure/abort-controller\";\nimport type {\n  HttpClient,\n  HttpHeaders as PipelineHeaders,\n  PipelineRequest,\n  PipelineResponse,\n  TransferProgressEvent,\n} from \"./interfaces.js\";\nimport { RestError } from \"./restError.js\";\nimport { createHttpHeaders } from \"./httpHeaders.js\";\nimport { isNodeReadableStream, isWebReadableStream } from \"./util/typeGuards.js\";\n\n/**\n * Checks if the body is a Blob or Blob-like\n */\nfunction isBlob(body: unknown): body is Blob {\n  // File objects count as a type of Blob, so we want to use instanceof explicitly\n  return (typeof Blob === \"function\" || typeof Blob === \"object\") && body instanceof Blob;\n}\n\n/**\n * A HttpClient implementation that uses window.fetch to send HTTP requests.\n * @internal\n */\nclass FetchHttpClient implements HttpClient {\n  /**\n   * Makes a request over an underlying transport layer and returns the response.\n   * @param request - The request to be made.\n   */\n  public async sendRequest(request: PipelineRequest): Promise<PipelineResponse> {\n    const url = new URL(request.url);\n    const isInsecure = url.protocol !== \"https:\";\n\n    if (isInsecure && !request.allowInsecureConnection) {\n      throw new Error(`Cannot connect to ${request.url} while allowInsecureConnection is false.`);\n    }\n\n    if (request.proxySettings) {\n      throw new Error(\"HTTP proxy is not supported in browser environment\");\n    }\n\n    try {\n      return await makeRequest(request);\n    } catch (e: any) {\n      throw getError(e, request);\n    }\n  }\n}\n\n/**\n * Sends a request\n */\nasync function makeRequest(request: PipelineRequest): Promise<PipelineResponse> {\n  const { abortController, abortControllerCleanup } = setupAbortSignal(request);\n  try {\n    const headers = buildFetchHeaders(request.headers);\n    const { streaming, body: requestBody } = buildRequestBody(request);\n    const requestInit: RequestInit = {\n      body: requestBody,\n      method: request.method,\n      headers: headers,\n      signal: abortController.signal,\n      // Cloudflare doesn't implement the full Fetch API spec\n      // because of some of it doesn't make sense in the edge.\n      // See https://github.com/cloudflare/workerd/issues/902\n      ...(\"credentials\" in Request.prototype\n        ? { credentials: request.withCredentials ? \"include\" : \"same-origin\" }\n        : {}),\n      ...(\"cache\" in Request.prototype ? { cache: \"no-store\" } : {}),\n    };\n\n    // According to https://fetch.spec.whatwg.org/#fetch-method,\n    // init.duplex must be set when body is a ReadableStream object.\n    // currently \"half\" is the only valid value.\n    if (streaming) {\n      (requestInit as any).duplex = \"half\";\n    }\n    /**\n     * Developers of the future:\n     * Do not set redirect: \"manual\" as part\n     * of request options.\n     * It will not work as you expect.\n     */\n    const response = await fetch(request.url, requestInit);\n    // If we're uploading a blob, we need to fire the progress event manually\n    if (isBlob(request.body) && request.onUploadProgress) {\n      request.onUploadProgress({ loadedBytes: request.body.size });\n    }\n    return buildPipelineResponse(response, request, abortControllerCleanup);\n  } catch (e) {\n    abortControllerCleanup?.();\n    throw e;\n  }\n}\n\n/**\n * Creates a pipeline response from a Fetch response;\n */\nasync function buildPipelineResponse(\n  httpResponse: Response,\n  request: PipelineRequest,\n  abortControllerCleanup?: () => void,\n): Promise<PipelineResponse> {\n  const headers = buildPipelineHeaders(httpResponse);\n  const response: PipelineResponse = {\n    request,\n    headers,\n    status: httpResponse.status,\n  };\n\n  const bodyStream = isWebReadableStream(httpResponse.body)\n    ? buildBodyStream(httpResponse.body, {\n        onProgress: request.onDownloadProgress,\n        onEnd: abortControllerCleanup,\n      })\n    : httpResponse.body;\n\n  if (\n    // Value of POSITIVE_INFINITY in streamResponseStatusCodes is considered as any status code\n    request.streamResponseStatusCodes?.has(Number.POSITIVE_INFINITY) ||\n    request.streamResponseStatusCodes?.has(response.status)\n  ) {\n    if (request.enableBrowserStreams) {\n      response.browserStreamBody = bodyStream ?? undefined;\n    } else {\n      const responseStream = new Response(bodyStream);\n      response.blobBody = responseStream.blob();\n      abortControllerCleanup?.();\n    }\n  } else {\n    const responseStream = new Response(bodyStream);\n\n    response.bodyAsText = await responseStream.text();\n    abortControllerCleanup?.();\n  }\n\n  return response;\n}\n\nfunction setupAbortSignal(request: PipelineRequest): {\n  abortController: AbortController;\n  abortControllerCleanup: (() => void) | undefined;\n} {\n  const abortController = new AbortController();\n\n  // Cleanup function\n  let abortControllerCleanup: (() => void) | undefined;\n\n  /**\n   * Attach an abort listener to the request\n   */\n  let abortListener: ((event: any) => void) | undefined;\n  if (request.abortSignal) {\n    if (request.abortSignal.aborted) {\n      throw new AbortError(\"The operation was aborted. Request has already been canceled.\");\n    }\n\n    abortListener = (event: Event) => {\n      if (event.type === \"abort\") {\n        abortController.abort();\n      }\n    };\n    request.abortSignal.addEventListener(\"abort\", abortListener);\n    abortControllerCleanup = () => {\n      if (abortListener) {\n        request.abortSignal?.removeEventListener(\"abort\", abortListener);\n      }\n    };\n  }\n\n  // If a timeout was passed, call the abort signal once the time elapses\n  if (request.timeout > 0) {\n    setTimeout(() => {\n      abortController.abort();\n    }, request.timeout);\n  }\n\n  return { abortController, abortControllerCleanup };\n}\n\n/**\n * Gets the specific error\n */\n// eslint-disable-next-line @azure/azure-sdk/ts-use-interface-parameters\nfunction getError(e: RestError, request: PipelineRequest): RestError {\n  if (e && e?.name === \"AbortError\") {\n    return e;\n  } else {\n    return new RestError(`Error sending request: ${e.message}`, {\n      code: e?.code ?? RestError.REQUEST_SEND_ERROR,\n      request,\n    });\n  }\n}\n\n/**\n * Converts PipelineRequest headers to Fetch headers\n */\nfunction buildFetchHeaders(pipelineHeaders: PipelineHeaders): Headers {\n  const headers = new Headers();\n  for (const [name, value] of pipelineHeaders) {\n    headers.append(name, value);\n  }\n\n  return headers;\n}\n\nfunction buildPipelineHeaders(httpResponse: Response): PipelineHeaders {\n  const responseHeaders = createHttpHeaders();\n  for (const [name, value] of httpResponse.headers) {\n    responseHeaders.set(name, value);\n  }\n\n  return responseHeaders;\n}\n\ninterface BuildRequestBodyResponse {\n  body:\n    | string\n    | Blob\n    | ReadableStream<Uint8Array>\n    | ArrayBuffer\n    | ArrayBufferView\n    | FormData\n    | null\n    | undefined;\n  streaming: boolean;\n}\n\nfunction buildRequestBody(request: PipelineRequest): BuildRequestBodyResponse {\n  const body = typeof request.body === \"function\" ? request.body() : request.body;\n  if (isNodeReadableStream(body)) {\n    throw new Error(\"Node streams are not supported in browser environment.\");\n  }\n\n  return isWebReadableStream(body)\n    ? { streaming: true, body: buildBodyStream(body, { onProgress: request.onUploadProgress }) }\n    : { streaming: false, body };\n}\n\n/**\n * Reads the request/response original stream and stream it through a new\n * ReadableStream, this is done to be able to report progress in a way that\n * all modern browsers support. TransformStreams would be an alternative,\n * however they are not yet supported by all browsers i.e Firefox\n */\nfunction buildBodyStream(\n  readableStream: ReadableStream<Uint8Array>,\n  options: { onProgress?: (progress: TransferProgressEvent) => void; onEnd?: () => void } = {},\n): ReadableStream<Uint8Array> {\n  let loadedBytes = 0;\n  const { onProgress, onEnd } = options;\n\n  // If the current browser supports pipeThrough we use a TransformStream\n  // to report progress\n  if (isTransformStreamSupported(readableStream)) {\n    return readableStream.pipeThrough(\n      new TransformStream({\n        transform(chunk, controller) {\n          if (chunk === null) {\n            controller.terminate();\n            return;\n          }\n\n          controller.enqueue(chunk);\n          loadedBytes += chunk.length;\n          if (onProgress) {\n            onProgress({ loadedBytes });\n          }\n        },\n        flush() {\n          onEnd?.();\n        },\n      }),\n    );\n  } else {\n    // If we can't use transform streams, wrap the original stream in a new readable stream\n    // and use pull to enqueue each chunk and report progress.\n    const reader = readableStream.getReader();\n    return new ReadableStream({\n      async pull(controller) {\n        const { done, value } = await reader.read();\n        // When no more data needs to be consumed, break the reading\n        if (done || !value) {\n          onEnd?.();\n          // Close the stream\n          controller.close();\n          reader.releaseLock();\n          return;\n        }\n\n        loadedBytes += value?.length ?? 0;\n\n        // Enqueue the next data chunk into our target stream\n        controller.enqueue(value);\n\n        if (onProgress) {\n          onProgress({ loadedBytes });\n        }\n      },\n      cancel(reason?: string) {\n        onEnd?.();\n        return reader.cancel(reason);\n      },\n    });\n  }\n}\n\n/**\n * Create a new HttpClient instance for the browser environment.\n * @internal\n */\nexport function createFetchHttpClient(): HttpClient {\n  return new FetchHttpClient();\n}\n\nfunction isTransformStreamSupported(readableStream: ReadableStream): boolean {\n  return readableStream.pipeThrough !== undefined && self.TransformStream !== undefined;\n}\n", "// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\n\nimport type { HttpClient } from \"./interfaces.js\";\nimport { createFetchHttpClient } from \"./fetchHttpClient.js\";\n\n/**\n * Create the correct HttpClient for the current environment.\n */\nexport function createDefaultHttpClient(): HttpClient {\n  return createFetchHttpClient();\n}\n", "// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\n\nimport type {\n  Agent,\n  FormDataMap,\n  HttpHeaders,\n  MultipartRequestBody,\n  PipelineRequest,\n  ProxySettings,\n  RequestBodyType,\n  TlsSettings,\n  TransferProgressEvent,\n} from \"./interfaces.js\";\nimport { createHttpHeaders } from \"./httpHeaders.js\";\nimport type { AbortSignalLike } from \"@azure/abort-controller\";\nimport { randomUUID } from \"@azure/core-util\";\nimport type { OperationTracingOptions } from \"@azure/core-tracing\";\nimport type { HttpMethods } from \"@azure/core-util\";\n\n/**\n * Settings to initialize a request.\n * Almost equivalent to Partial<PipelineRequest>, but url is mandatory.\n */\nexport interface PipelineRequestOptions {\n  /**\n   * The URL to make the request to.\n   */\n  url: string;\n\n  /**\n   * The HTTP method to use when making the request.\n   */\n  method?: HttpMethods;\n\n  /**\n   * The HTTP headers to use when making the request.\n   */\n  headers?: HttpHeaders;\n\n  /**\n   * The number of milliseconds a request can take before automatically being terminated.\n   * If the request is terminated, an `AbortError` is thrown.\n   * Defaults to 0, which disables the timeout.\n   */\n  timeout?: number;\n\n  /**\n   * If credentials (cookies) should be sent along during an XHR.\n   * Defaults to false.\n   */\n  withCredentials?: boolean;\n\n  /**\n   * A unique identifier for the request. Used for logging and tracing.\n   */\n  requestId?: string;\n\n  /**\n   * The HTTP body content (if any)\n   */\n  body?: RequestBodyType;\n\n  /**\n   * Body for a multipart request.\n   */\n  multipartBody?: MultipartRequestBody;\n\n  /**\n   * To simulate a browser form post\n   */\n  formData?: FormDataMap;\n\n  /**\n   * A list of response status codes whose corresponding PipelineResponse body should be treated as a stream.\n   */\n  streamResponseStatusCodes?: Set<number>;\n\n  /**\n   * NODEJS ONLY\n   *\n   * A Node-only option to provide a custom `http.Agent`/`https.Agent`.\n   * NOTE: usually this should be one instance shared by multiple requests so that the underlying\n   *       connection to the service can be reused.\n   * Does nothing when running in the browser.\n   */\n  agent?: Agent;\n\n  /**\n   * BROWSER ONLY\n   *\n   * A browser only option to enable use of the Streams API. If this option is set and streaming is used\n   * (see `streamResponseStatusCodes`), the response will have a property `browserStream` instead of\n   * `blobBody` which will be undefined.\n   *\n   * Default value is false\n   */\n  enableBrowserStreams?: boolean;\n\n  /** Settings for configuring TLS authentication */\n  tlsSettings?: TlsSettings;\n\n  /**\n   * Proxy configuration.\n   */\n  proxySettings?: ProxySettings;\n\n  /**\n   * If the connection should not be reused.\n   */\n  disableKeepAlive?: boolean;\n\n  /**\n   * Used to abort the request later.\n   */\n  abortSignal?: AbortSignalLike;\n\n  /**\n   * Options used to create a span when tracing is enabled.\n   */\n  tracingOptions?: OperationTracingOptions;\n\n  /**\n   * Callback which fires upon upload progress.\n   */\n  onUploadProgress?: (progress: TransferProgressEvent) => void;\n\n  /** Callback which fires upon download progress. */\n  onDownloadProgress?: (progress: TransferProgressEvent) => void;\n\n  /** Set to true if the request is sent over HTTP instead of HTTPS */\n  allowInsecureConnection?: boolean;\n}\n\nclass PipelineRequestImpl implements PipelineRequest {\n  public url: string;\n  public method: HttpMethods;\n  public headers: HttpHeaders;\n  public timeout: number;\n  public withCredentials: boolean;\n  public body?: RequestBodyType;\n  public multipartBody?: MultipartRequestBody;\n  public formData?: FormDataMap;\n  public streamResponseStatusCodes?: Set<number>;\n  public enableBrowserStreams: boolean;\n  public proxySettings?: ProxySettings;\n  public disableKeepAlive: boolean;\n  public abortSignal?: AbortSignalLike;\n  public requestId: string;\n  public tracingOptions?: OperationTracingOptions;\n  public allowInsecureConnection?: boolean;\n  public onUploadProgress?: (progress: TransferProgressEvent) => void;\n  public onDownloadProgress?: (progress: TransferProgressEvent) => void;\n  public agent?: Agent;\n  public tlsSettings?: TlsSettings;\n\n  constructor(options: PipelineRequestOptions) {\n    this.url = options.url;\n    this.body = options.body;\n    this.headers = options.headers ?? createHttpHeaders();\n    this.method = options.method ?? \"GET\";\n    this.timeout = options.timeout ?? 0;\n    this.multipartBody = options.multipartBody;\n    this.formData = options.formData;\n    this.disableKeepAlive = options.disableKeepAlive ?? false;\n    this.proxySettings = options.proxySettings;\n    this.streamResponseStatusCodes = options.streamResponseStatusCodes;\n    this.withCredentials = options.withCredentials ?? false;\n    this.abortSignal = options.abortSignal;\n    this.tracingOptions = options.tracingOptions;\n    this.onUploadProgress = options.onUploadProgress;\n    this.onDownloadProgress = options.onDownloadProgress;\n    this.requestId = options.requestId || randomUUID();\n    this.allowInsecureConnection = options.allowInsecureConnection ?? false;\n    this.enableBrowserStreams = options.enableBrowserStreams ?? false;\n    this.agent = options.agent;\n    this.tlsSettings = options.tlsSettings;\n  }\n}\n\n/**\n * Creates a new pipeline request with the given options.\n * This method is to allow for the easy setting of default values and not required.\n * @param options - The options to create the request with.\n */\nexport function createPipelineRequest(options: PipelineRequestOptions): PipelineRequest {\n  return new PipelineRequestImpl(options);\n}\n", "// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\n\nimport type { PipelinePolicy } from \"../pipeline.js\";\nimport { exponentialRetryStrategy } from \"../retryStrategies/exponentialRetryStrategy.js\";\nimport { retryPolicy } from \"./retryPolicy.js\";\nimport { DEFAULT_RETRY_POLICY_COUNT } from \"../constants.js\";\n\n/**\n * The programmatic identifier of the exponentialRetryPolicy.\n */\nexport const exponentialRetryPolicyName = \"exponentialRetryPolicy\";\n\n/**\n * Options that control how to retry failed requests.\n */\nexport interface ExponentialRetryPolicyOptions {\n  /**\n   * The maximum number of retry attempts. Defaults to 3.\n   */\n  maxRetries?: number;\n\n  /**\n   * The amount of delay in milliseconds between retry attempts. Defaults to 1000\n   * (1 second.) The delay increases exponentially with each retry up to a maximum\n   * specified by maxRetryDelayInMs.\n   */\n  retryDelayInMs?: number;\n\n  /**\n   * The maximum delay in milliseconds allowed before retrying an operation. Defaults\n   * to 64000 (64 seconds).\n   */\n  maxRetryDelayInMs?: number;\n}\n\n/**\n * A policy that attempts to retry requests while introducing an exponentially increasing delay.\n * @param options - Options that configure retry logic.\n */\nexport function exponentialRetryPolicy(\n  options: ExponentialRetryPolicyOptions = {},\n): PipelinePolicy {\n  return retryPolicy(\n    [\n      exponentialRetryStrategy({\n        ...options,\n        ignoreSystemErrors: true,\n      }),\n    ],\n    {\n      maxRetries: options.maxRetries ?? DEFAULT_RETRY_POLICY_COUNT,\n    },\n  );\n}\n", "// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\n\nimport type { PipelinePolicy } from \"../pipeline.js\";\nimport { exponentialRetryStrategy } from \"../retryStrategies/exponentialRetryStrategy.js\";\nimport { retryPolicy } from \"./retryPolicy.js\";\nimport { DEFAULT_RETRY_POLICY_COUNT } from \"../constants.js\";\n\n/**\n * Name of the {@link systemErrorRetryPolicy}\n */\nexport const systemErrorRetryPolicyName = \"systemErrorRetryPolicy\";\n\n/**\n * Options that control how to retry failed requests.\n */\nexport interface SystemErrorRetryPolicyOptions {\n  /**\n   * The maximum number of retry attempts. Defaults to 3.\n   */\n  maxRetries?: number;\n\n  /**\n   * The amount of delay in milliseconds between retry attempts. Defaults to 1000\n   * (1 second.) The delay increases exponentially with each retry up to a maximum\n   * specified by maxRetryDelayInMs.\n   */\n  retryDelayInMs?: number;\n\n  /**\n   * The maximum delay in milliseconds allowed before retrying an operation. Defaults\n   * to 64000 (64 seconds).\n   */\n  maxRetryDelayInMs?: number;\n}\n\n/**\n * A retry policy that specifically seeks to handle errors in the\n * underlying transport layer (e.g. DNS lookup failures) rather than\n * retryable error codes from the server itself.\n * @param options - Options that customize the policy.\n */\nexport function systemErrorRetryPolicy(\n  options: SystemErrorRetryPolicyOptions = {},\n): PipelinePolicy {\n  return {\n    name: systemErrorRetryPolicyName,\n    sendRequest: retryPolicy(\n      [\n        exponentialRetryStrategy({\n          ...options,\n          ignoreHttpStatusCodes: true,\n        }),\n      ],\n      {\n        maxRetries: options.maxRetries ?? DEFAULT_RETRY_POLICY_COUNT,\n      },\n    ).sendRequest,\n  };\n}\n", "// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\n\nimport type { PipelinePolicy } from \"../pipeline.js\";\nimport { throttlingRetryStrategy } from \"../retryStrategies/throttlingRetryStrategy.js\";\nimport { retryPolicy } from \"./retryPolicy.js\";\nimport { DEFAULT_RETRY_POLICY_COUNT } from \"../constants.js\";\n\n/**\n * Name of the {@link throttlingRetryPolicy}\n */\nexport const throttlingRetryPolicyName = \"throttlingRetryPolicy\";\n\n/**\n * Options that control how to retry failed requests.\n */\nexport interface ThrottlingRetryPolicyOptions {\n  /**\n   * The maximum number of retry attempts. Defaults to 3.\n   */\n  maxRetries?: number;\n}\n\n/**\n * A policy that retries when the server sends a 429 response with a Retry-After header.\n *\n * To learn more, please refer to\n * https://learn.microsoft.com/en-us/azure/azure-resource-manager/resource-manager-request-limits,\n * https://learn.microsoft.com/en-us/azure/azure-subscription-service-limits and\n * https://learn.microsoft.com/en-us/azure/virtual-machines/troubleshooting/troubleshooting-throttling-errors\n *\n * @param options - Options that configure retry logic.\n */\nexport function throttlingRetryPolicy(options: ThrottlingRetryPolicyOptions = {}): PipelinePolicy {\n  return {\n    name: throttlingRetryPolicyName,\n    sendRequest: retryPolicy([throttlingRetryStrategy()], {\n      maxRetries: options.maxRetries ?? DEFAULT_RETRY_POLICY_COUNT,\n    }).sendRequest,\n  };\n}\n", "// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\n\nimport type { AccessToken, GetTokenOptions, TokenCredential } from \"@azure/core-auth\";\nimport { delay } from \"./helpers.js\";\n\n/**\n * A function that gets a promise of an access token and allows providing\n * options.\n *\n * @param options - the options to pass to the underlying token provider\n */\nexport type AccessTokenGetter = (\n  scopes: string | string[],\n  options: GetTokenOptions,\n) => Promise<AccessToken>;\n\nexport interface TokenCyclerOptions {\n  /**\n   * The window of time before token expiration during which the token will be\n   * considered unusable due to risk of the token expiring before sending the\n   * request.\n   *\n   * This will only become meaningful if the refresh fails for over\n   * (refreshWindow - forcedRefreshWindow) milliseconds.\n   */\n  forcedRefreshWindowInMs: number;\n  /**\n   * Interval in milliseconds to retry failed token refreshes.\n   */\n  retryIntervalInMs: number;\n  /**\n   * The window of time before token expiration during which\n   * we will attempt to refresh the token.\n   */\n  refreshWindowInMs: number;\n}\n\n// Default options for the cycler if none are provided\nexport const DEFAULT_CYCLER_OPTIONS: TokenCyclerOptions = {\n  forcedRefreshWindowInMs: 1000, // Force waiting for a refresh 1s before the token expires\n  retryIntervalInMs: 3000, // Allow refresh attempts every 3s\n  refreshWindowInMs: 1000 * 60 * 2, // Start refreshing 2m before expiry\n};\n\n/**\n * Converts an an unreliable access token getter (which may resolve with null)\n * into an AccessTokenGetter by retrying the unreliable getter in a regular\n * interval.\n *\n * @param getAccessToken - A function that produces a promise of an access token that may fail by returning null.\n * @param retryIntervalInMs - The time (in milliseconds) to wait between retry attempts.\n * @param refreshTimeout - The timestamp after which the refresh attempt will fail, throwing an exception.\n * @returns - A promise that, if it resolves, will resolve with an access token.\n */\nasync function beginRefresh(\n  getAccessToken: () => Promise<AccessToken | null>,\n  retryIntervalInMs: number,\n  refreshTimeout: number,\n): Promise<AccessToken> {\n  // This wrapper handles exceptions gracefully as long as we haven't exceeded\n  // the timeout.\n  async function tryGetAccessToken(): Promise<AccessToken | null> {\n    if (Date.now() < refreshTimeout) {\n      try {\n        return await getAccessToken();\n      } catch {\n        return null;\n      }\n    } else {\n      const finalToken = await getAccessToken();\n\n      // Timeout is up, so throw if it's still null\n      if (finalToken === null) {\n        throw new Error(\"Failed to refresh access token.\");\n      }\n\n      return finalToken;\n    }\n  }\n\n  let token: AccessToken | null = await tryGetAccessToken();\n\n  while (token === null) {\n    await delay(retryIntervalInMs);\n\n    token = await tryGetAccessToken();\n  }\n\n  return token;\n}\n\n/**\n * Creates a token cycler from a credential, scopes, and optional settings.\n *\n * A token cycler represents a way to reliably retrieve a valid access token\n * from a TokenCredential. It will handle initializing the token, refreshing it\n * when it nears expiration, and synchronizes refresh attempts to avoid\n * concurrency hazards.\n *\n * @param credential - the underlying TokenCredential that provides the access\n * token\n * @param tokenCyclerOptions - optionally override default settings for the cycler\n *\n * @returns - a function that reliably produces a valid access token\n */\nexport function createTokenCycler(\n  credential: TokenCredential,\n  tokenCyclerOptions?: Partial<TokenCyclerOptions>,\n): AccessTokenGetter {\n  let refreshWorker: Promise<AccessToken> | null = null;\n  let token: AccessToken | null = null;\n  let tenantId: string | undefined;\n\n  const options = {\n    ...DEFAULT_CYCLER_OPTIONS,\n    ...tokenCyclerOptions,\n  };\n\n  /**\n   * This little holder defines several predicates that we use to construct\n   * the rules of refreshing the token.\n   */\n  const cycler = {\n    /**\n     * Produces true if a refresh job is currently in progress.\n     */\n    get isRefreshing(): boolean {\n      return refreshWorker !== null;\n    },\n    /**\n     * Produces true if the cycler SHOULD refresh (we are within the refresh\n     * window and not already refreshing)\n     */\n    get shouldRefresh(): boolean {\n      if (cycler.isRefreshing) {\n        return false;\n      }\n      if (token?.refreshAfterTimestamp && token.refreshAfterTimestamp < Date.now()) {\n        return true;\n      }\n\n      return (token?.expiresOnTimestamp ?? 0) - options.refreshWindowInMs < Date.now();\n    },\n    /**\n     * Produces true if the cycler MUST refresh (null or nearly-expired\n     * token).\n     */\n    get mustRefresh(): boolean {\n      return (\n        token === null || token.expiresOnTimestamp - options.forcedRefreshWindowInMs < Date.now()\n      );\n    },\n  };\n\n  /**\n   * Starts a refresh job or returns the existing job if one is already\n   * running.\n   */\n  function refresh(\n    scopes: string | string[],\n    getTokenOptions: GetTokenOptions,\n  ): Promise<AccessToken> {\n    if (!cycler.isRefreshing) {\n      // We bind `scopes` here to avoid passing it around a lot\n      const tryGetAccessToken = (): Promise<AccessToken | null> =>\n        credential.getToken(scopes, getTokenOptions);\n\n      // Take advantage of promise chaining to insert an assignment to `token`\n      // before the refresh can be considered done.\n      refreshWorker = beginRefresh(\n        tryGetAccessToken,\n        options.retryIntervalInMs,\n        // If we don't have a token, then we should timeout immediately\n        token?.expiresOnTimestamp ?? Date.now(),\n      )\n        .then((_token) => {\n          refreshWorker = null;\n          token = _token;\n          tenantId = getTokenOptions.tenantId;\n          return token;\n        })\n        .catch((reason) => {\n          // We also should reset the refresher if we enter a failed state.  All\n          // existing awaiters will throw, but subsequent requests will start a\n          // new retry chain.\n          refreshWorker = null;\n          token = null;\n          tenantId = undefined;\n          throw reason;\n        });\n    }\n\n    return refreshWorker as Promise<AccessToken>;\n  }\n\n  return async (scopes: string | string[], tokenOptions: GetTokenOptions): Promise<AccessToken> => {\n    //\n    // Simple rules:\n    // - If we MUST refresh, then return the refresh task, blocking\n    //   the pipeline until a token is available.\n    // - If we SHOULD refresh, then run refresh but don't return it\n    //   (we can still use the cached token).\n    // - Return the token, since it's fine if we didn't return in\n    //   step 1.\n    //\n\n    const hasClaimChallenge = Boolean(tokenOptions.claims);\n    const tenantIdChanged = tenantId !== tokenOptions.tenantId;\n\n    if (hasClaimChallenge) {\n      // If we've received a claim, we know the existing token isn't valid\n      // We want to clear it so that that refresh worker won't use the old expiration time as a timeout\n      token = null;\n    }\n\n    // If the tenantId passed in token options is different to the one we have\n    // Or if we are in claim challenge and the token was rejected and a new access token need to be issued, we need to\n    // refresh the token with the new tenantId or token.\n    const mustRefresh = tenantIdChanged || hasClaimChallenge || cycler.mustRefresh;\n\n    if (mustRefresh) {\n      return refresh(scopes, tokenOptions);\n    }\n\n    if (cycler.shouldRefresh) {\n      refresh(scopes, tokenOptions);\n    }\n\n    return token as AccessToken;\n  };\n}\n", "// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\n\nimport type { AccessToken, GetTokenOptions, TokenCredential } from \"@azure/core-auth\";\nimport type { AzureLogger } from \"@azure/logger\";\nimport type { PipelineRequest, PipelineResponse, SendRequest } from \"../interfaces.js\";\nimport type { PipelinePolicy } from \"../pipeline.js\";\nimport { createTokenCycler } from \"../util/tokenCycler.js\";\nimport { logger as coreLogger } from \"../log.js\";\nimport type { RestError } from \"../restError.js\";\nimport { isRestError } from \"../restError.js\";\n\n/**\n * The programmatic identifier of the bearerTokenAuthenticationPolicy.\n */\nexport const bearerTokenAuthenticationPolicyName = \"bearerTokenAuthenticationPolicy\";\n\n/**\n * Options sent to the authorizeRequest callback\n */\nexport interface AuthorizeRequestOptions {\n  /**\n   * The scopes for which the bearer token applies.\n   */\n  scopes: string[];\n  /**\n   * Function that retrieves either a cached access token or a new access token.\n   */\n  getAccessToken: (scopes: string[], options: GetTokenOptions) => Promise<AccessToken | null>;\n  /**\n   * Request that the policy is trying to fulfill.\n   */\n  request: PipelineRequest;\n  /**\n   * A logger, if one was sent through the HTTP pipeline.\n   */\n  logger?: AzureLogger;\n}\n\n/**\n * Options sent to the authorizeRequestOnChallenge callback\n */\nexport interface AuthorizeRequestOnChallengeOptions {\n  /**\n   * The scopes for which the bearer token applies.\n   */\n  scopes: string[];\n  /**\n   * Function that retrieves either a cached access token or a new access token.\n   */\n  getAccessToken: (scopes: string[], options: GetTokenOptions) => Promise<AccessToken | null>;\n  /**\n   * Request that the policy is trying to fulfill.\n   */\n  request: PipelineRequest;\n  /**\n   * Response containing the challenge.\n   */\n  response: PipelineResponse;\n  /**\n   * A logger, if one was sent through the HTTP pipeline.\n   */\n  logger?: AzureLogger;\n}\n\n/**\n * Options to override the processing of [Continuous Access Evaluation](https://learn.microsoft.com/azure/active-directory/conditional-access/concept-continuous-access-evaluation) challenges.\n */\nexport interface ChallengeCallbacks {\n  /**\n   * Allows for the authorization of the main request of this policy before it's sent.\n   */\n  authorizeRequest?(options: AuthorizeRequestOptions): Promise<void>;\n  /**\n   * Allows to handle authentication challenges and to re-authorize the request.\n   * The response containing the challenge is `options.response`.\n   * If this method returns true, the underlying request will be sent once again.\n   * The request may be modified before being sent.\n   */\n  authorizeRequestOnChallenge?(options: AuthorizeRequestOnChallengeOptions): Promise<boolean>;\n}\n\n/**\n * Options to configure the bearerTokenAuthenticationPolicy\n */\nexport interface BearerTokenAuthenticationPolicyOptions {\n  /**\n   * The TokenCredential implementation that can supply the bearer token.\n   */\n  credential?: TokenCredential;\n  /**\n   * The scopes for which the bearer token applies.\n   */\n  scopes: string | string[];\n  /**\n   * Allows for the processing of [Continuous Access Evaluation](https://learn.microsoft.com/azure/active-directory/conditional-access/concept-continuous-access-evaluation) challenges.\n   * If provided, it must contain at least the `authorizeRequestOnChallenge` method.\n   * If provided, after a request is sent, if it has a challenge, it can be processed to re-send the original request with the relevant challenge information.\n   */\n  challengeCallbacks?: ChallengeCallbacks;\n  /**\n   * A logger can be sent for debugging purposes.\n   */\n  logger?: AzureLogger;\n}\n/**\n * Try to send the given request.\n *\n * When a response is received, returns a tuple of the response received and, if the response was received\n * inside a thrown RestError, the RestError that was thrown.\n *\n * Otherwise, if an error was thrown while sending the request that did not provide an underlying response, it\n * will be rethrown.\n */\nasync function trySendRequest(\n  request: PipelineRequest,\n  next: SendRequest,\n): Promise<[PipelineResponse, RestError | undefined]> {\n  try {\n    return [await next(request), undefined];\n  } catch (e: any) {\n    if (isRestError(e) && e.response) {\n      return [e.response, e];\n    } else {\n      throw e;\n    }\n  }\n}\n/**\n * Default authorize request handler\n */\nasync function defaultAuthorizeRequest(options: AuthorizeRequestOptions): Promise<void> {\n  const { scopes, getAccessToken, request } = options;\n  // Enable CAE true by default\n  const getTokenOptions: GetTokenOptions = {\n    abortSignal: request.abortSignal,\n    tracingOptions: request.tracingOptions,\n    enableCae: true,\n  };\n\n  const accessToken = await getAccessToken(scopes, getTokenOptions);\n\n  if (accessToken) {\n    options.request.headers.set(\"Authorization\", `Bearer ${accessToken.token}`);\n  }\n}\n\n/**\n * We will retrieve the challenge only if the response status code was 401,\n * and if the response contained the header \"WWW-Authenticate\" with a non-empty value.\n */\nfunction isChallengeResponse(response: PipelineResponse): boolean {\n  return response.status === 401 && response.headers.has(\"WWW-Authenticate\");\n}\n\n/**\n * Re-authorize the request for CAE challenge.\n * The response containing the challenge is `options.response`.\n * If this method returns true, the underlying request will be sent once again.\n */\nasync function authorizeRequestOnCaeChallenge(\n  onChallengeOptions: AuthorizeRequestOnChallengeOptions,\n  caeClaims: string,\n): Promise<boolean> {\n  const { scopes } = onChallengeOptions;\n\n  const accessToken = await onChallengeOptions.getAccessToken(scopes, {\n    enableCae: true,\n    claims: caeClaims,\n  });\n  if (!accessToken) {\n    return false;\n  }\n\n  onChallengeOptions.request.headers.set(\n    \"Authorization\",\n    `${accessToken.tokenType ?? \"Bearer\"} ${accessToken.token}`,\n  );\n  return true;\n}\n\n/**\n * A policy that can request a token from a TokenCredential implementation and\n * then apply it to the Authorization header of a request as a Bearer token.\n */\nexport function bearerTokenAuthenticationPolicy(\n  options: BearerTokenAuthenticationPolicyOptions,\n): PipelinePolicy {\n  const { credential, scopes, challengeCallbacks } = options;\n  const logger = options.logger || coreLogger;\n  const callbacks = {\n    authorizeRequest:\n      challengeCallbacks?.authorizeRequest?.bind(challengeCallbacks) ?? defaultAuthorizeRequest,\n    authorizeRequestOnChallenge:\n      challengeCallbacks?.authorizeRequestOnChallenge?.bind(challengeCallbacks),\n  };\n\n  // This function encapsulates the entire process of reliably retrieving the token\n  // The options are left out of the public API until there's demand to configure this.\n  // Remember to extend `BearerTokenAuthenticationPolicyOptions` with `TokenCyclerOptions`\n  // in order to pass through the `options` object.\n  const getAccessToken = credential\n    ? createTokenCycler(credential /* , options */)\n    : () => Promise.resolve(null);\n\n  return {\n    name: bearerTokenAuthenticationPolicyName,\n    /**\n     * If there's no challenge parameter:\n     * - It will try to retrieve the token using the cache, or the credential's getToken.\n     * - Then it will try the next policy with or without the retrieved token.\n     *\n     * It uses the challenge parameters to:\n     * - Skip a first attempt to get the token from the credential if there's no cached token,\n     *   since it expects the token to be retrievable only after the challenge.\n     * - Prepare the outgoing request if the `prepareRequest` method has been provided.\n     * - Send an initial request to receive the challenge if it fails.\n     * - Process a challenge if the response contains it.\n     * - Retrieve a token with the challenge information, then re-send the request.\n     */\n    async sendRequest(request: PipelineRequest, next: SendRequest): Promise<PipelineResponse> {\n      if (!request.url.toLowerCase().startsWith(\"https://\")) {\n        throw new Error(\n          \"Bearer token authentication is not permitted for non-TLS protected (non-https) URLs.\",\n        );\n      }\n\n      await callbacks.authorizeRequest({\n        scopes: Array.isArray(scopes) ? scopes : [scopes],\n        request,\n        getAccessToken,\n        logger,\n      });\n\n      let response: PipelineResponse;\n      let error: Error | undefined;\n      let shouldSendRequest: boolean;\n      [response, error] = await trySendRequest(request, next);\n\n      if (isChallengeResponse(response)) {\n        let claims = getCaeChallengeClaims(response.headers.get(\"WWW-Authenticate\"));\n        // Handle CAE by default when receive CAE claim\n        if (claims) {\n          let parsedClaim: string;\n          // Return the response immediately if claims is not a valid base64 encoded string\n          try {\n            parsedClaim = atob(claims);\n          } catch (e) {\n            logger.warning(\n              `The WWW-Authenticate header contains \"claims\" that cannot be parsed. Unable to perform the Continuous Access Evaluation authentication flow. Unparsable claims: ${claims}`,\n            );\n            return response;\n          }\n          shouldSendRequest = await authorizeRequestOnCaeChallenge(\n            {\n              scopes: Array.isArray(scopes) ? scopes : [scopes],\n              response,\n              request,\n              getAccessToken,\n              logger,\n            },\n            parsedClaim,\n          );\n          // Send updated request and handle response for RestError\n          if (shouldSendRequest) {\n            [response, error] = await trySendRequest(request, next);\n          }\n        } else if (callbacks.authorizeRequestOnChallenge) {\n          // Handle custom challenges when client provides custom callback\n          shouldSendRequest = await callbacks.authorizeRequestOnChallenge({\n            scopes: Array.isArray(scopes) ? scopes : [scopes],\n            request,\n            response,\n            getAccessToken,\n            logger,\n          });\n\n          // Send updated request and handle response for RestError\n          if (shouldSendRequest) {\n            [response, error] = await trySendRequest(request, next);\n          }\n\n          // If we get another CAE Claim, we will handle it by default and return whatever value we receive for this\n          if (isChallengeResponse(response)) {\n            claims = getCaeChallengeClaims(response.headers.get(\"WWW-Authenticate\") as string);\n            if (claims) {\n              let parsedClaim: string;\n              try {\n                parsedClaim = atob(claims);\n              } catch (e) {\n                logger.warning(\n                  `The WWW-Authenticate header contains \"claims\" that cannot be parsed. Unable to perform the Continuous Access Evaluation authentication flow. Unparsable claims: ${claims}`,\n                );\n                return response;\n              }\n\n              shouldSendRequest = await authorizeRequestOnCaeChallenge(\n                {\n                  scopes: Array.isArray(scopes) ? scopes : [scopes],\n                  response,\n                  request,\n                  getAccessToken,\n                  logger,\n                },\n                parsedClaim,\n              );\n              // Send updated request and handle response for RestError\n              if (shouldSendRequest) {\n                [response, error] = await trySendRequest(request, next);\n              }\n            }\n          }\n        }\n      }\n\n      if (error) {\n        throw error;\n      } else {\n        return response;\n      }\n    },\n  };\n}\n\n/**\n *\n * Interface to represent a parsed challenge.\n *\n * @internal\n */\ninterface AuthChallenge {\n  scheme: string;\n  params: Record<string, string>;\n}\n\n/**\n * Converts: `Bearer a=\"b\", c=\"d\", Pop e=\"f\", g=\"h\"`.\n * Into: `[ { scheme: 'Bearer', params: { a: 'b', c: 'd' } }, { scheme: 'Pop', params: { e: 'f', g: 'h' } } ]`.\n *\n * @internal\n */\nexport function parseChallenges(challenges: string): AuthChallenge[] {\n  // Challenge regex seperates the string to individual challenges with different schemes in the format `Scheme a=\"b\", c=d`\n  // The challenge regex captures parameteres with either quotes values or unquoted values\n  const challengeRegex = /(\\w+)\\s+((?:\\w+=(?:\"[^\"]*\"|[^,]*),?\\s*)+)/g;\n  // Parameter regex captures the claims group removed from the scheme in the format `a=\"b\"` and `c=\"d\"`\n  // CAE challenge always have quoted parameters. For more reference, https://learn.microsoft.com/entra/identity-platform/claims-challenge\n  const paramRegex = /(\\w+)=\"([^\"]*)\"/g;\n\n  const parsedChallenges: AuthChallenge[] = [];\n  let match;\n\n  // Iterate over each challenge match\n  while ((match = challengeRegex.exec(challenges)) !== null) {\n    const scheme = match[1];\n    const paramsString = match[2];\n    const params: Record<string, string> = {};\n    let paramMatch;\n\n    // Iterate over each parameter match\n    while ((paramMatch = paramRegex.exec(paramsString)) !== null) {\n      params[paramMatch[1]] = paramMatch[2];\n    }\n\n    parsedChallenges.push({ scheme, params });\n  }\n  return parsedChallenges;\n}\n\n/**\n * Parse a pipeline response and look for a CAE challenge with \"Bearer\" scheme\n * Return the value in the header without parsing the challenge\n * @internal\n */\nfunction getCaeChallengeClaims(challenges: string | undefined): string | undefined {\n  if (!challenges) {\n    return;\n  }\n  // Find all challenges present in the header\n  const parsedChallenges = parseChallenges(challenges);\n  return parsedChallenges.find(\n    (x) => x.scheme === \"Bearer\" && x.params.claims && x.params.error === \"insufficient_claims\",\n  )?.params.claims;\n}\n", "// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\n\nimport type { PipelineRequest, PipelineResponse, SendRequest } from \"../interfaces.js\";\nimport type { PipelinePolicy } from \"../pipeline.js\";\n\n/**\n * The programmatic identifier of the ndJsonPolicy.\n */\nexport const ndJsonPolicyName = \"ndJsonPolicy\";\n\n/**\n * ndJsonPolicy is a policy used to control keep alive settings for every request.\n */\nexport function ndJsonPolicy(): PipelinePolicy {\n  return {\n    name: ndJsonPolicyName,\n    async sendRequest(request: PipelineRequest, next: SendRequest): Promise<PipelineResponse> {\n      // There currently isn't a good way to bypass the serializer\n      if (typeof request.body === \"string\" && request.body.startsWith(\"[\")) {\n        const body = JSON.parse(request.body);\n        if (Array.isArray(body)) {\n          request.body = body.map((item) => JSON.stringify(item) + \"\\n\").join(\"\");\n        }\n      }\n      return next(request);\n    },\n  };\n}\n", "// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\n\nimport type { GetTokenOptions, TokenCredential } from \"@azure/core-auth\";\nimport type { AzureLogger } from \"@azure/logger\";\nimport type { PipelineRequest, PipelineResponse, SendRequest } from \"../interfaces.js\";\nimport type { PipelinePolicy } from \"../pipeline.js\";\nimport { type AccessTokenGetter, createTokenCycler } from \"../util/tokenCycler.js\";\nimport { logger as coreLogger } from \"../log.js\";\nimport type { AuthorizeRequestOptions } from \"./bearerTokenAuthenticationPolicy.js\";\n\n/**\n * The programmatic identifier of the auxiliaryAuthenticationHeaderPolicy.\n */\nexport const auxiliaryAuthenticationHeaderPolicyName = \"auxiliaryAuthenticationHeaderPolicy\";\nconst AUTHORIZATION_AUXILIARY_HEADER = \"x-ms-authorization-auxiliary\";\n\n/**\n * Options to configure the auxiliaryAuthenticationHeaderPolicy\n */\nexport interface AuxiliaryAuthenticationHeaderPolicyOptions {\n  /**\n   * TokenCredential list used to get token from auxiliary tenants and\n   * one credential for each tenant the client may need to access\n   */\n  credentials?: TokenCredential[];\n  /**\n   * Scopes depend on the cloud your application runs in\n   */\n  scopes: string | string[];\n  /**\n   * A logger can be sent for debugging purposes.\n   */\n  logger?: AzureLogger;\n}\n\nasync function sendAuthorizeRequest(options: AuthorizeRequestOptions): Promise<string> {\n  const { scopes, getAccessToken, request } = options;\n  const getTokenOptions: GetTokenOptions = {\n    abortSignal: request.abortSignal,\n    tracingOptions: request.tracingOptions,\n  };\n\n  return (await getAccessToken(scopes, getTokenOptions))?.token ?? \"\";\n}\n\n/**\n * A policy for external tokens to `x-ms-authorization-auxiliary` header.\n * This header will be used when creating a cross-tenant application we may need to handle authentication requests\n * for resources that are in different tenants.\n * You could see [ARM docs](https://learn.microsoft.com/en-us/azure/azure-resource-manager/management/authenticate-multi-tenant) for a rundown of how this feature works\n */\nexport function auxiliaryAuthenticationHeaderPolicy(\n  options: AuxiliaryAuthenticationHeaderPolicyOptions,\n): PipelinePolicy {\n  const { credentials, scopes } = options;\n  const logger = options.logger || coreLogger;\n  const tokenCyclerMap = new WeakMap<TokenCredential, AccessTokenGetter>();\n\n  return {\n    name: auxiliaryAuthenticationHeaderPolicyName,\n    async sendRequest(request: PipelineRequest, next: SendRequest): Promise<PipelineResponse> {\n      if (!request.url.toLowerCase().startsWith(\"https://\")) {\n        throw new Error(\n          \"Bearer token authentication for auxiliary header is not permitted for non-TLS protected (non-https) URLs.\",\n        );\n      }\n      if (!credentials || credentials.length === 0) {\n        logger.info(\n          `${auxiliaryAuthenticationHeaderPolicyName} header will not be set due to empty credentials.`,\n        );\n        return next(request);\n      }\n\n      const tokenPromises: Promise<string>[] = [];\n      for (const credential of credentials) {\n        let getAccessToken = tokenCyclerMap.get(credential);\n        if (!getAccessToken) {\n          getAccessToken = createTokenCycler(credential);\n          tokenCyclerMap.set(credential, getAccessToken);\n        }\n        tokenPromises.push(\n          sendAuthorizeRequest({\n            scopes: Array.isArray(scopes) ? scopes : [scopes],\n            request,\n            getAccessToken,\n            logger,\n          }),\n        );\n      }\n      const auxiliaryTokens = (await Promise.all(tokenPromises)).filter((token) => Boolean(token));\n      if (auxiliaryTokens.length === 0) {\n        logger.warning(\n          `None of the auxiliary tokens are valid. ${AUTHORIZATION_AUXILIARY_HEADER} header will not be set.`,\n        );\n        return next(request);\n      }\n      request.headers.set(\n        AUTHORIZATION_AUXILIARY_HEADER,\n        auxiliaryTokens.map((token) => `Bearer ${token}`).join(\", \"),\n      );\n\n      return next(request);\n    },\n  };\n}\n", "// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\n\ndeclare global {\n  interface FormData {}\n  interface Blob {}\n  interface File {}\n  interface ReadableStream<R = any> {}\n  interface TransformStream<I = any, O = any> {}\n}\n\nexport type { HttpMethods } from \"@azure/core-util\";\nexport type {\n  Agent,\n  BodyPart,\n  FormDataMap,\n  FormDataValue,\n  HttpClient,\n  HttpHeaders,\n  KeyObject,\n  MultipartRequestBody,\n  PipelineRequest,\n  PipelineResponse,\n  PipelineRetryOptions,\n  ProxySettings,\n  PxfObject,\n  RawHttpHeaders,\n  RawHttpHeadersInput,\n  RequestBodyType,\n  SendRequest,\n  TlsSettings,\n  TransferProgressEvent,\n} from \"./interfaces.js\";\nexport {\n  type AddPolicyOptions as AddPipelineOptions,\n  type PipelinePhase,\n  type PipelinePolicy,\n  type Pipeline,\n  createEmptyPipeline,\n} from \"./pipeline.js\";\nexport {\n  createPipelineFromOptions,\n  type TelemetryOptions,\n  type InternalPipelineOptions,\n  type PipelineOptions,\n} from \"./createPipelineFromOptions.js\";\nexport { createDefaultHttpClient } from \"./defaultHttpClient.js\";\nexport { createHttpHeaders } from \"./httpHeaders.js\";\nexport { createPipelineRequest, type PipelineRequestOptions } from \"./pipelineRequest.js\";\nexport { RestError, type RestErrorOptions, isRestError } from \"./restError.js\";\nexport {\n  decompressResponsePolicy,\n  decompressResponsePolicyName,\n} from \"./policies/decompressResponsePolicy.js\";\nexport {\n  exponentialRetryPolicy,\n  type ExponentialRetryPolicyOptions,\n  exponentialRetryPolicyName,\n} from \"./policies/exponentialRetryPolicy.js\";\nexport {\n  setClientRequestIdPolicy,\n  setClientRequestIdPolicyName,\n} from \"./policies/setClientRequestIdPolicy.js\";\nexport { logPolicy, logPolicyName, type LogPolicyOptions } from \"./policies/logPolicy.js\";\nexport { multipartPolicy, multipartPolicyName } from \"./policies/multipartPolicy.js\";\nexport { proxyPolicy, proxyPolicyName, getDefaultProxySettings } from \"./policies/proxyPolicy.js\";\nexport {\n  redirectPolicy,\n  redirectPolicyName,\n  type RedirectPolicyOptions,\n} from \"./policies/redirectPolicy.js\";\nexport {\n  systemErrorRetryPolicy,\n  type SystemErrorRetryPolicyOptions,\n  systemErrorRetryPolicyName,\n} from \"./policies/systemErrorRetryPolicy.js\";\nexport {\n  throttlingRetryPolicy,\n  throttlingRetryPolicyName,\n  type ThrottlingRetryPolicyOptions,\n} from \"./policies/throttlingRetryPolicy.js\";\nexport { retryPolicy, type RetryPolicyOptions } from \"./policies/retryPolicy.js\";\nexport type {\n  RetryStrategy,\n  RetryInformation,\n  RetryModifiers,\n} from \"./retryStrategies/retryStrategy.js\";\nexport {\n  tracingPolicy,\n  tracingPolicyName,\n  type TracingPolicyOptions,\n} from \"./policies/tracingPolicy.js\";\nexport {\n  defaultRetryPolicy,\n  type DefaultRetryPolicyOptions,\n} from \"./policies/defaultRetryPolicy.js\";\nexport {\n  userAgentPolicy,\n  userAgentPolicyName,\n  type UserAgentPolicyOptions,\n} from \"./policies/userAgentPolicy.js\";\nexport { tlsPolicy, tlsPolicyName } from \"./policies/tlsPolicy.js\";\nexport { formDataPolicy, formDataPolicyName } from \"./policies/formDataPolicy.js\";\nexport {\n  bearerTokenAuthenticationPolicy,\n  type BearerTokenAuthenticationPolicyOptions,\n  bearerTokenAuthenticationPolicyName,\n  type ChallengeCallbacks,\n  type AuthorizeRequestOptions,\n  type AuthorizeRequestOnChallengeOptions,\n} from \"./policies/bearerTokenAuthenticationPolicy.js\";\nexport { ndJsonPolicy, ndJsonPolicyName } from \"./policies/ndJsonPolicy.js\";\nexport {\n  auxiliaryAuthenticationHeaderPolicy,\n  type AuxiliaryAuthenticationHeaderPolicyOptions,\n  auxiliaryAuthenticationHeaderPolicyName,\n} from \"./policies/auxiliaryAuthenticationHeaderPolicy.js\";\nexport { agentPolicy, agentPolicyName } from \"./policies/agentPolicy.js\";\nexport {\n  createFile,\n  createFileFromStream,\n  type CreateFileOptions,\n  type CreateFileFromStreamOptions,\n} from \"./util/file.js\";\n", "// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { AccessToken } from \"@azure/core-auth\";\nimport { jwtDecode } from \"jwt-decode\";\n\ninterface JwtToken {\n  exp: number;\n}\n\nexport const parseToken = (token: string): AccessToken => {\n  const { exp } = jwtDecode<JwtToken>(token);\n  return {\n    token,\n    expiresOnTimestamp: exp * 1000,\n  };\n};\n", "// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { CommunicationGetTokenOptions, TokenCredential } from \"./communicationTokenCredential\";\nimport { AbortSignalLike } from \"@azure/abort-controller\";\nimport { AccessToken } from \"@azure/core-auth\";\nimport { parseToken } from \"./tokenParser\";\n\n/**\n * Options for auto-refreshing a Communication Token credential.\n */\nexport interface CommunicationTokenRefreshOptions {\n  /**\n   * Callback function that returns a string JWT token acquired from the Communication Identity API.\n   * The returned token must be valid (expiration date must be in the future).\n   */\n  tokenRefresher: (abortSignal?: AbortSignalLike) => Promise<string>;\n\n  /**\n   * Optional token to initialize.\n   */\n  token?: string;\n\n  /**\n   * Indicates whether the token should be proactively renewed prior to expiry or only renew on demand.\n   * By default false.\n   */\n  refreshProactively?: boolean;\n}\n\nconst expiredToken = { token: \"\", expiresOnTimestamp: -10 };\nconst minutesToMs = (minutes: number): number => minutes * 1000 * 60;\nconst defaultExpiringSoonInterval = minutesToMs(10);\nconst defaultRefreshAfterLifetimePercentage = 0.5;\n\nexport class AutoRefreshTokenCredential implements TokenCredential {\n  private readonly refresh: (abortSignal?: AbortSignalLike) => Promise<string>;\n  private readonly refreshProactively: boolean;\n  private readonly expiringSoonIntervalInMs: number = defaultExpiringSoonInterval;\n  private readonly refreshAfterLifetimePercentage = defaultRefreshAfterLifetimePercentage;\n\n  private currentToken: AccessToken;\n  private activeTimeout: ReturnType<typeof setTimeout> | undefined;\n  private activeTokenFetching: Promise<string> | null = null;\n  private activeTokenUpdating: Promise<void> | null = null;\n  private disposed = false;\n\n  constructor(refreshArgs: CommunicationTokenRefreshOptions) {\n    const { tokenRefresher, token, refreshProactively } = refreshArgs;\n\n    this.refresh = tokenRefresher;\n    this.currentToken = token ? parseToken(token) : expiredToken;\n    this.refreshProactively = refreshProactively ?? false;\n\n    if (this.refreshProactively) {\n      this.scheduleRefresh();\n    }\n  }\n\n  public async getToken(options?: CommunicationGetTokenOptions): Promise<AccessToken> {\n    if (!this.isTokenExpiringSoon(this.currentToken)) {\n      return this.currentToken;\n    }\n\n    if (!this.isTokenValid(this.currentToken)) {\n      const updatePromise = this.updateTokenAndReschedule(options?.abortSignal);\n      await updatePromise;\n    }\n\n    return this.currentToken;\n  }\n\n  public dispose(): void {\n    this.disposed = true;\n    this.activeTokenFetching = null;\n    this.activeTokenUpdating = null;\n    this.currentToken = expiredToken;\n    if (this.activeTimeout) {\n      clearTimeout(this.activeTimeout);\n    }\n  }\n\n  private async updateTokenAndReschedule(abortSignal?: AbortSignalLike): Promise<void> {\n    if (this.activeTokenUpdating) {\n      return this.activeTokenUpdating;\n    }\n    this.activeTokenUpdating = this.refreshTokenAndReschedule(abortSignal);\n    try {\n      await this.activeTokenUpdating;\n    } finally {\n      this.activeTokenUpdating = null;\n    }\n  }\n\n  private async refreshTokenAndReschedule(abortSignal?: AbortSignalLike): Promise<void> {\n    const newToken = await this.refreshToken(abortSignal);\n\n    if (!this.isTokenValid(newToken)) {\n      throw new Error(\"The token returned from the tokenRefresher is expired.\");\n    }\n\n    this.currentToken = newToken;\n    if (this.refreshProactively) {\n      this.scheduleRefresh();\n    }\n  }\n\n  private async refreshToken(abortSignal?: AbortSignalLike): Promise<AccessToken> {\n    try {\n      if (!this.activeTokenFetching) {\n        this.activeTokenFetching = this.refresh(abortSignal);\n      }\n      return parseToken(await this.activeTokenFetching);\n    } finally {\n      this.activeTokenFetching = null;\n    }\n  }\n\n  private scheduleRefresh(): void {\n    if (this.disposed) {\n      return;\n    }\n    if (this.activeTimeout) {\n      clearTimeout(this.activeTimeout);\n    }\n    const tokenTtlInMs = this.currentToken.expiresOnTimestamp - Date.now();\n    let timespanInMs = null;\n\n    if (this.isTokenExpiringSoon(this.currentToken)) {\n      // Schedule the next refresh for when it reaches a certain percentage of the remaining lifetime.\n      timespanInMs = tokenTtlInMs * this.refreshAfterLifetimePercentage;\n    } else {\n      // Schedule the next refresh for when it gets in to the soon-to-expire window.\n      timespanInMs = tokenTtlInMs - this.expiringSoonIntervalInMs;\n    }\n\n    this.activeTimeout = setTimeout(() => this.updateTokenAndReschedule(), timespanInMs);\n  }\n\n  private isTokenValid(token: AccessToken): boolean {\n    return token && Date.now() < token.expiresOnTimestamp;\n  }\n\n  private isTokenExpiringSoon(token: AccessToken): boolean {\n    return !token || Date.now() >= token.expiresOnTimestamp - this.expiringSoonIntervalInMs;\n  }\n}\n", "// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { AccessToken } from \"@azure/core-auth\";\nimport { TokenCredential } from \"./communicationTokenCredential\";\n\n/**\n * StaticTokenCredential\n */\nexport class StaticTokenCredential implements TokenCredential {\n  constructor(private readonly token: AccessToken) {}\n\n  public async getToken(): Promise<AccessToken> {\n    return this.token;\n  }\n\n  public dispose(): void {\n    /* intentionally empty */\n  }\n}\n", "// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport {\n  AutoRefreshTokenCredential,\n  CommunicationTokenRefreshOptions,\n} from \"./autoRefreshTokenCredential\";\nimport {\n  CommunicationGetTokenOptions,\n  CommunicationTokenCredential,\n  TokenCredential,\n} from \"./communicationTokenCredential\";\nimport { AccessToken } from \"@azure/core-auth\";\nimport { StaticTokenCredential } from \"./staticTokenCredential\";\nimport { parseToken } from \"./tokenParser\";\n\n/**\n * The CommunicationTokenCredential implementation with support for proactive token refresh.\n */\n\nexport class AzureCommunicationTokenCredential implements CommunicationTokenCredential {\n  private readonly tokenCredential: TokenCredential;\n  private disposed = false;\n\n  /**\n   * Creates an instance of CommunicationTokenCredential with a static token and no proactive refreshing.\n   * @param token - A user access token issued by Communication Services.\n   */\n  constructor(token: string);\n  /**\n   * Creates an instance of CommunicationTokenCredential with a lambda to get a token and options\n   * to configure proactive refreshing.\n   * @param refreshOptions - Options to configure refresh and opt-in to proactive refreshing.\n   */\n  constructor(refreshOptions: CommunicationTokenRefreshOptions);\n  constructor(tokenOrRefreshOptions: string | CommunicationTokenRefreshOptions) {\n    if (typeof tokenOrRefreshOptions === \"string\") {\n      this.tokenCredential = new StaticTokenCredential(parseToken(tokenOrRefreshOptions));\n    } else {\n      this.tokenCredential = new AutoRefreshTokenCredential(tokenOrRefreshOptions);\n    }\n  }\n\n  /**\n   * Gets an `AccessToken` for the user. Throws if already disposed.\n   * @param abortSignal - An implementation of `AbortSignalLike` to cancel the operation.\n   */\n  public async getToken(options?: CommunicationGetTokenOptions): Promise<AccessToken> {\n    this.throwIfDisposed();\n    const token = await this.tokenCredential.getToken(options);\n    this.throwIfDisposed();\n    return token;\n  }\n\n  /**\n   * Disposes the CommunicationTokenCredential and cancels any internal auto-refresh operation.\n   */\n  public dispose(): void {\n    this.disposed = true;\n    this.tokenCredential.dispose();\n  }\n\n  private throwIfDisposed(): void {\n    if (this.disposed) {\n      throw new Error(\"User credential is disposed\");\n    }\n  }\n}\n", "// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nexport const encodeUTF8 = (str: string): Uint8Array => new TextEncoder().encode(str);\n\nexport function encodeUTF8fromBase64(str: string): Uint8Array {\n  if (typeof atob !== \"function\") {\n    throw new Error(\"Your browser environment is missing the global `atob` function\");\n  }\n  const binary = atob(str);\n  const bytes = new Uint8Array(binary.length);\n  for (let i = 0; i < binary.length; i++) {\n    bytes[i] = binary.charCodeAt(i);\n  }\n  return bytes;\n}\n\nexport function encodeBase64(value: ArrayBuffer): string {\n  if (typeof btoa !== \"function\") {\n    throw new Error(\"Your browser environment is missing the global `btoa` function\");\n  }\n  const bytes = new Uint8Array(value);\n  let binary = \"\";\n  for (const byte of bytes) {\n    binary += String.fromCharCode(byte);\n  }\n  return btoa(binary);\n}\n", "// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\n/// <reference lib=\"dom\" />\n\nimport { encodeBase64, encodeUTF8, encodeUTF8fromBase64 } from \"./encodeUtils.browser\";\n\nconst subtle = (globalThis as any)?.crypto?.subtle as SubtleCrypto;\n\nexport const shaHash = async (content: string): Promise<string> => {\n  const data = encodeUTF8(content);\n  const hash = await subtle.digest(\"SHA-256\", data);\n  return encodeBase64(hash);\n};\n\nexport const shaHMAC = async (secret: string, content: string): Promise<string> => {\n  const importParams: HmacImportParams = { name: \"HMAC\", hash: { name: \"SHA-256\" } };\n  const encodedMessage = encodeUTF8(content);\n  const encodedKey = encodeUTF8fromBase64(secret);\n  const crypto = subtle;\n  const cryptoKey = await crypto.importKey(\"raw\", encodedKey, importParams, false, [\"sign\"]);\n  const signature = await crypto.sign(importParams, cryptoKey, encodedMessage);\n  return encodeBase64(signature);\n};\n", "// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport {\n  PipelinePolicy,\n  PipelineRequest,\n  PipelineResponse,\n  SendRequest,\n} from \"@azure/core-rest-pipeline\";\nimport { shaHMAC, shaHash } from \"./cryptoUtils\";\nimport { KeyCredential } from \"@azure/core-auth\";\nimport { isNode } from \"@azure/core-util\";\n\n/**\n * CommunicationKeyCredentialPolicy provides a means of signing requests made through\n * the SmsClient.\n */\nconst communicationAccessKeyCredentialPolicy = \"CommunicationAccessKeyCredentialPolicy\";\n\n/**\n * Creates an HTTP pipeline policy to authenticate a request using a `KeyCredential`.\n * @hidden\n *\n * @param credential - The key credential.\n */\nexport function createCommunicationAccessKeyCredentialPolicy(\n  credential: KeyCredential,\n): PipelinePolicy {\n  return {\n    name: communicationAccessKeyCredentialPolicy,\n    async sendRequest(request: PipelineRequest, next: SendRequest): Promise<PipelineResponse> {\n      const verb = request.method.toUpperCase();\n      const utcNow = new Date().toUTCString();\n      const contentHash = await shaHash(request.body?.toString() || \"\");\n      const dateHeader = \"x-ms-date\";\n      const signedHeaders = `${dateHeader};host;x-ms-content-sha256`;\n\n      const url = new URL(request.url);\n      const query = url.searchParams.toString();\n      const urlPathAndQuery = query ? `${url.pathname}?${query}` : url.pathname;\n      const port = url.port;\n      const hostAndPort = port ? `${url.host}:${port}` : url.host;\n\n      const stringToSign = `${verb}\\n${urlPathAndQuery}\\n${utcNow};${hostAndPort};${contentHash}`;\n      const signature = await shaHMAC(credential.key, stringToSign);\n\n      if (isNode) {\n        request.headers.set(\"Host\", hostAndPort || \"\");\n      }\n\n      request.headers.set(dateHeader, utcNow);\n      request.headers.set(\"x-ms-content-sha256\", contentHash);\n      request.headers.set(\n        \"Authorization\",\n        `HMAC-SHA256 SignedHeaders=${signedHeaders}&Signature=${signature}`,\n      );\n      return next(request);\n    },\n  };\n}\n", "// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport {\n  BearerTokenAuthenticationPolicyOptions,\n  PipelinePolicy,\n  bearerTokenAuthenticationPolicy,\n} from \"@azure/core-rest-pipeline\";\nimport { KeyCredential, TokenCredential, isTokenCredential } from \"@azure/core-auth\";\nimport { createCommunicationAccessKeyCredentialPolicy } from \"./communicationAccessKeyCredentialPolicy\";\n/**\n * Creates a pipeline policy to authenticate request based\n * on the credential passed in.\n * @hidden\n *\n * @param credential - The KeyCredential or TokenCredential.\n */\nexport function createCommunicationAuthPolicy(\n  credential: KeyCredential | TokenCredential,\n): PipelinePolicy {\n  if (isTokenCredential(credential)) {\n    const policyOptions: BearerTokenAuthenticationPolicyOptions = {\n      credential: credential,\n      scopes: [\"https://communication.azure.com//.default\"],\n    };\n    return bearerTokenAuthenticationPolicy(policyOptions);\n  } else {\n    return createCommunicationAccessKeyCredentialPolicy(credential);\n  }\n}\n", "// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\n\nimport { KeyCredential } from \"./keyCredential.js\";\n\n/**\n * A static-key-based credential that supports updating\n * the underlying key value.\n */\nexport class AzureKeyCredential implements KeyCredential {\n  private _key: string;\n\n  /**\n   * The value of the key to be used in authentication\n   */\n  public get key(): string {\n    return this._key;\n  }\n\n  /**\n   * Create an instance of an AzureKeyCredential for use\n   * with a service client.\n   *\n   * @param key - The initial value of the key to use in authentication\n   */\n  constructor(key: string) {\n    if (!key) {\n      throw new Error(\"key must be a non-empty string\");\n    }\n\n    this._key = key;\n  }\n\n  /**\n   * Change the value of the key.\n   *\n   * Updates will take effect upon the next request after\n   * updating the key value.\n   *\n   * @param newKey - The new key value to be used\n   */\n  public update(newKey: string): void {\n    this._key = newKey;\n  }\n}\n", "// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\n\nimport { isObjectWithProperties } from \"@azure/core-util\";\n\n/**\n * Represents a credential defined by a static API key.\n */\nexport interface KeyCredential {\n  /**\n   * The value of the API key represented as a string\n   */\n  readonly key: string;\n}\n\n/**\n * Tests an object to determine whether it implements KeyCredential.\n *\n * @param credential - The assumed KeyCredential to be tested.\n */\nexport function isKeyCredential(credential: unknown): credential is KeyCredential {\n  return isObjectWithProperties(credential, [\"key\"]) && typeof credential.key === \"string\";\n}\n", "// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\n\nimport { isObjectWithProperties } from \"@azure/core-util\";\n\n/**\n * Represents a credential defined by a static API name and key.\n */\nexport interface NamedKeyCredential {\n  /**\n   * The value of the API key represented as a string\n   */\n  readonly key: string;\n  /**\n   * The value of the API name represented as a string.\n   */\n  readonly name: string;\n}\n\n/**\n * A static name/key-based credential that supports updating\n * the underlying name and key values.\n */\nexport class AzureNamedKeyCredential implements NamedKeyCredential {\n  private _key: string;\n  private _name: string;\n\n  /**\n   * The value of the key to be used in authentication.\n   */\n  public get key(): string {\n    return this._key;\n  }\n\n  /**\n   * The value of the name to be used in authentication.\n   */\n  public get name(): string {\n    return this._name;\n  }\n\n  /**\n   * Create an instance of an AzureNamedKeyCredential for use\n   * with a service client.\n   *\n   * @param name - The initial value of the name to use in authentication.\n   * @param key - The initial value of the key to use in authentication.\n   */\n  constructor(name: string, key: string) {\n    if (!name || !key) {\n      throw new TypeError(\"name and key must be non-empty strings\");\n    }\n\n    this._name = name;\n    this._key = key;\n  }\n\n  /**\n   * Change the value of the key.\n   *\n   * Updates will take effect upon the next request after\n   * updating the key value.\n   *\n   * @param newName - The new name value to be used.\n   * @param newKey - The new key value to be used.\n   */\n  public update(newName: string, newKey: string): void {\n    if (!newName || !newKey) {\n      throw new TypeError(\"newName and newKey must be non-empty strings\");\n    }\n\n    this._name = newName;\n    this._key = newKey;\n  }\n}\n\n/**\n * Tests an object to determine whether it implements NamedKeyCredential.\n *\n * @param credential - The assumed NamedKeyCredential to be tested.\n */\nexport function isNamedKeyCredential(credential: unknown): credential is NamedKeyCredential {\n  return (\n    isObjectWithProperties(credential, [\"name\", \"key\"]) &&\n    typeof credential.key === \"string\" &&\n    typeof credential.name === \"string\"\n  );\n}\n", "// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\n\nimport { isObjectWithProperties } from \"@azure/core-util\";\n\n/**\n * Represents a credential defined by a static shared access signature.\n */\nexport interface SASCredential {\n  /**\n   * The value of the shared access signature represented as a string\n   */\n  readonly signature: string;\n}\n\n/**\n * A static-signature-based credential that supports updating\n * the underlying signature value.\n */\nexport class AzureSASCredential implements SASCredential {\n  private _signature: string;\n\n  /**\n   * The value of the shared access signature to be used in authentication\n   */\n  public get signature(): string {\n    return this._signature;\n  }\n\n  /**\n   * Create an instance of an AzureSASCredential for use\n   * with a service client.\n   *\n   * @param signature - The initial value of the shared access signature to use in authentication\n   */\n  constructor(signature: string) {\n    if (!signature) {\n      throw new Error(\"shared access signature must be a non-empty string\");\n    }\n\n    this._signature = signature;\n  }\n\n  /**\n   * Change the value of the signature.\n   *\n   * Updates will take effect upon the next request after\n   * updating the signature value.\n   *\n   * @param newSignature - The new shared access signature value to be used\n   */\n  public update(newSignature: string): void {\n    if (!newSignature) {\n      throw new Error(\"shared access signature must be a non-empty string\");\n    }\n\n    this._signature = newSignature;\n  }\n}\n\n/**\n * Tests an object to determine whether it implements SASCredential.\n *\n * @param credential - The assumed SASCredential to be tested.\n */\nexport function isSASCredential(credential: unknown): credential is SASCredential {\n  return (\n    isObjectWithProperties(credential, [\"signature\"]) && typeof credential.signature === \"string\"\n  );\n}\n", "// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\n\nimport { AbortSignalLike } from \"@azure/abort-controller\";\nimport { TracingContext } from \"./tracing.js\";\nimport { HttpMethods } from \"@azure/core-util\";\n\n/**\n * Represents a credential capable of providing an authentication token.\n */\nexport interface TokenCredential {\n  /**\n   * Gets the token provided by this credential.\n   *\n   * This method is called automatically by Azure SDK client libraries. You may call this method\n   * directly, but you must also handle token caching and token refreshing.\n   *\n   * @param scopes - The list of scopes for which the token will have access.\n   * @param options - The options used to configure any requests this\n   *                TokenCredential implementation might make.\n   */\n  getToken(scopes: string | string[], options?: GetTokenOptions): Promise<AccessToken | null>;\n}\n\n/**\n * Defines options for TokenCredential.getToken.\n */\nexport interface GetTokenOptions {\n  /**\n   * The signal which can be used to abort requests.\n   */\n  abortSignal?: AbortSignalLike;\n  /**\n   * Options used when creating and sending HTTP requests for this operation.\n   */\n  requestOptions?: {\n    /**\n     * The number of milliseconds a request can take before automatically being terminated.\n     */\n    timeout?: number;\n  };\n  /**\n   * Options used when tracing is enabled.\n   */\n  tracingOptions?: {\n    /**\n     * Tracing Context for the current request.\n     */\n    tracingContext?: TracingContext;\n  };\n  /**\n   * Claim details to perform the Continuous Access Evaluation authentication flow\n   */\n  claims?: string;\n  /**\n   * Indicates whether to enable the Continuous Access Evaluation authentication flow\n   */\n  enableCae?: boolean;\n  /**\n   * Allows specifying a tenantId. Useful to handle challenges that provide tenant Id hints.\n   */\n  tenantId?: string;\n\n  /**\n   * Options for Proof of Possession token requests\n   */\n  proofOfPossessionOptions?: {\n    /**\n     * The nonce value required for PoP token requests.\n     * This is typically retrieved from the WWW-Authenticate header of a 401 challenge response.\n     * This is used in combination with {@link resourceRequestUrl} and {@link resourceRequestMethod} to generate the PoP token.\n     */\n    nonce: string;\n    /**\n     * The HTTP method of the request.\n     * This is used in combination with {@link resourceRequestUrl} and {@link nonce} to generate the PoP token.\n     */\n    resourceRequestMethod: HttpMethods;\n    /**\n     * The URL of the request.\n     * This is used in combination with {@link resourceRequestMethod} and {@link nonce} to generate the PoP token.\n     */\n    resourceRequestUrl: string;\n  };\n}\n\n/**\n * Represents an access token with an expiration time.\n */\nexport interface AccessToken {\n  /**\n   * The access token returned by the authentication service.\n   */\n  token: string;\n\n  /**\n   * The access token's expiration timestamp in milliseconds, UNIX epoch time.\n   */\n  expiresOnTimestamp: number;\n\n  /**\n   * The timestamp when the access token should be refreshed, in milliseconds, UNIX epoch time.\n   */\n  refreshAfterTimestamp?: number;\n\n  /** Type of token - `Bearer` or `pop` */\n  tokenType?: \"Bearer\" | \"pop\";\n}\n\n/**\n * @internal\n * @param accessToken - Access token\n * @returns Whether a token is bearer type or not\n */\nexport function isBearerToken(accessToken: AccessToken): boolean {\n  return !accessToken.tokenType || accessToken.tokenType === \"Bearer\";\n}\n\n/**\n * @internal\n * @param accessToken - Access token\n * @returns Whether a token is Pop token or not\n */\nexport function isPopToken(accessToken: AccessToken): boolean {\n  return accessToken.tokenType === \"pop\";\n}\n\n/**\n * Tests an object to determine whether it implements TokenCredential.\n *\n * @param credential - The assumed TokenCredential to be tested.\n */\nexport function isTokenCredential(credential: unknown): credential is TokenCredential {\n  // Check for an object with a 'getToken' function and possibly with\n  // a 'signRequest' function.  We do this check to make sure that\n  // a ServiceClientCredentials implementor (like TokenClientCredentials\n  // in ms-rest-nodeauth) doesn't get mistaken for a TokenCredential if\n  // it doesn't actually implement TokenCredential also.\n  const castCredential = credential as {\n    getToken: unknown;\n    signRequest: unknown;\n  };\n  return (\n    castCredential &&\n    typeof castCredential.getToken === \"function\" &&\n    (castCredential.signRequest === undefined || castCredential.getToken.length > 0)\n  );\n}\n", "// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { AzureKeyCredential, KeyCredential } from \"@azure/core-auth\";\n/**\n * Represents different properties of connection string\n * using format \"/endpoint=(.*);accesskey=(.*)\".\n * @hidden\n */\nexport interface EndpointCredential {\n  /**\n   * The endpoint as string\n   */\n  endpoint: string;\n  /**\n   * The access key represented as a KeyCredential object\n   */\n  credential: KeyCredential;\n}\n\n// TODO: update when connection string format is finalized\nconst CONNECTION_STRING_REGEX = /endpoint=(.*);accesskey=(.*)/i;\n\nconst tryParseConnectionString = (s: string): EndpointCredential | undefined => {\n  const match = s.match(CONNECTION_STRING_REGEX);\n  if (match?.[1] && match[2]) {\n    return { endpoint: match[1], credential: new AzureKeyCredential(match[2]) };\n  }\n  return undefined;\n};\n/**\n * Returns an EndpointCredential to easily access properties of the connection string.\n * @hidden\n *\n * @param connectionString - The connection string to parse\n * @returns Object to access the endpoint and the credentials\n */\nexport const parseConnectionString = (connectionString: string): EndpointCredential => {\n  const parsedConnectionString = tryParseConnectionString(connectionString);\n  if (parsedConnectionString) {\n    return parsedConnectionString;\n  } else {\n    throw new Error(`Invalid connection string ${connectionString}`);\n  }\n};\n", "// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { KeyCredential, TokenCredential, isTokenCredential } from \"@azure/core-auth\";\nimport { parseConnectionString } from \"./connectionString\";\n\nconst isValidEndpoint = (host: string): boolean => {\n  const url = new URL(host);\n\n  return (\n    !!url.protocol?.match(/^http[s]?/) &&\n    url.host !== undefined &&\n    url.host !== \"\" &&\n    (url.pathname === undefined || url.pathname === \"\" || url.pathname === \"/\")\n  );\n};\n\nconst assertValidEndpoint = (host: string): void => {\n  if (!isValidEndpoint(host)) {\n    throw new Error(`Invalid endpoint url ${host}`);\n  }\n};\n\n/**\n * Checks whether a value is a KeyCredential.\n *\n * @param credential - The credential being checked.\n */\nexport const isKeyCredential = (credential: unknown): credential is KeyCredential => {\n  const castCredential = credential as {\n    key: unknown;\n    getToken: unknown;\n  };\n  return (\n    castCredential &&\n    typeof castCredential.key === \"string\" &&\n    castCredential.getToken === undefined\n  );\n};\n\n/**\n * The URL and credential from parsing the arguments of a communication client.\n * @hidden\n */\nexport type UrlWithCredential = {\n  url: string;\n  credential: TokenCredential | KeyCredential;\n};\n\n/**\n * Parses arguments passed to a communication client.\n * @hidden\n */\nexport const parseClientArguments = (\n  connectionStringOrUrl: string,\n  credentialOrOptions?: unknown,\n): UrlWithCredential => {\n  if (isKeyCredential(credentialOrOptions) || isTokenCredential(credentialOrOptions)) {\n    assertValidEndpoint(connectionStringOrUrl);\n    return { url: connectionStringOrUrl, credential: credentialOrOptions };\n  } else {\n    const { endpoint: host, credential } = parseConnectionString(connectionStringOrUrl);\n    assertValidEndpoint(host);\n    return { url: host, credential };\n  }\n};\n", "// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\n/**\n * Identifies a communication participant.\n */\nexport type CommunicationIdentifier =\n  | CommunicationUserIdentifier\n  | PhoneNumberIdentifier\n  | MicrosoftTeamsUserIdentifier\n  | MicrosoftTeamsAppIdentifier\n  | UnknownIdentifier;\n\n/**\n * An Azure Communication user.\n */\nexport interface CommunicationUserIdentifier {\n  /**\n   * Id of the CommunicationUser as returned from the Communication Service.\n   */\n  communicationUserId: string;\n}\n\n/**\n * A phone number.\n */\nexport interface PhoneNumberIdentifier {\n  /**\n   * Optional raw id of the phone number.\n   */\n  rawId?: string;\n  /**\n   * The phone number in E.164 format.\n   */\n  phoneNumber: string;\n}\n\n/**\n * A Microsoft Teams user.\n */\nexport interface MicrosoftTeamsUserIdentifier {\n  /**\n   * Optional raw id of the Microsoft Teams user.\n   */\n  rawId?: string;\n\n  /**\n   * Id of the Microsoft Teams user. If the user isn't anonymous, the id is the AAD object id of the user.\n   */\n  microsoftTeamsUserId: string;\n\n  /**\n   * True if the user is anonymous, for example when joining a meeting with a share link. If missing, the user is not anonymous.\n   */\n  isAnonymous?: boolean;\n\n  /**\n   * The cloud that the Microsoft Teams user belongs to. If missing, the cloud is \"public\".\n   */\n  cloud?: \"public\" | \"dod\" | \"gcch\";\n}\n\n/**\n * A Microsoft Teams App.\n */\nexport interface MicrosoftTeamsAppIdentifier {\n  /**\n   * Optional raw id of the Microsoft Teams App.\n   */\n  rawId?: string;\n\n  /**\n   * The unique Microsoft Teams app ID.\n   */\n  teamsAppId: string;\n\n  /**\n   * The cloud that the Microsoft Temas App belongs to. If missing, the cloud is \"public\".\n   */\n  cloud?: \"public\" | \"dod\" | \"gcch\";\n}\n\n/**\n * An unknown identifier that doesn't fit any of the other identifier types.\n */\nexport interface UnknownIdentifier {\n  /**\n   * Id of the UnknownIdentifier.\n   */\n  id: string;\n}\n\n/**\n * Tests an Identifier to determine whether it implements CommunicationUserIdentifier.\n *\n * @param identifier - The assumed CommunicationUserIdentifier to be tested.\n */\nexport const isCommunicationUserIdentifier = (\n  identifier: CommunicationIdentifier,\n): identifier is CommunicationUserIdentifier => {\n  return typeof (identifier as any).communicationUserId === \"string\";\n};\n\n/**\n * Tests an Identifier to determine whether it implements PhoneNumberIdentifier.\n *\n * @param identifier - The assumed PhoneNumberIdentifier to be tested.\n */\nexport const isPhoneNumberIdentifier = (\n  identifier: CommunicationIdentifier,\n): identifier is PhoneNumberIdentifier => {\n  return typeof (identifier as any).phoneNumber === \"string\";\n};\n\n/**\n * Tests an Identifier to determine whether it implements MicrosoftTeamsUserIdentifier.\n *\n * @param identifier - The assumed available to be tested.\n */\nexport const isMicrosoftTeamsUserIdentifier = (\n  identifier: CommunicationIdentifier,\n): identifier is MicrosoftTeamsUserIdentifier => {\n  return typeof (identifier as any).microsoftTeamsUserId === \"string\";\n};\n\n/**\n * Tests an Identifier to determine whether it implements MicrosoftTeamsAppIdentifier.\n *\n * @param identifier - The assumed available to be tested.\n */\nexport const isMicrosoftTeamsAppIdentifier = (\n  identifier: CommunicationIdentifier,\n): identifier is MicrosoftTeamsAppIdentifier => {\n  return typeof (identifier as any).teamsAppId === \"string\";\n};\n\n/**\n * Tests an Identifier to determine whether it implements UnknownIdentifier.\n *\n * @param identifier - The assumed UnknownIdentifier to be tested.\n */\nexport const isUnknownIdentifier = (\n  identifier: CommunicationIdentifier,\n): identifier is UnknownIdentifier => {\n  return typeof (identifier as any).id === \"string\";\n};\n\n/**\n * The CommunicationIdentifierKind is a discriminated union that adds a property `kind` to an Identifier.\n */\nexport type CommunicationIdentifierKind =\n  | CommunicationUserKind\n  | PhoneNumberKind\n  | MicrosoftTeamsUserKind\n  | MicrosoftTeamsAppKind\n  | UnknownIdentifierKind;\n\n/**\n * IdentifierKind for a CommunicationUserIdentifier.\n */\nexport interface CommunicationUserKind extends CommunicationUserIdentifier {\n  /**\n   * The identifier kind.\n   */\n  kind: \"communicationUser\";\n}\n\n/**\n * IdentifierKind for a PhoneNumberIdentifier.\n */\nexport interface PhoneNumberKind extends PhoneNumberIdentifier {\n  /**\n   * The identifier kind.\n   */\n  kind: \"phoneNumber\";\n}\n\n/**\n * IdentifierKind for a MicrosoftTeamsUserIdentifier.\n */\nexport interface MicrosoftTeamsUserKind extends MicrosoftTeamsUserIdentifier {\n  /**\n   * The identifier kind.\n   */\n  kind: \"microsoftTeamsUser\";\n}\n\n/**\n * IdentifierKind for a MicrosoftTeamsAppIdentifier.\n */\nexport interface MicrosoftTeamsAppKind extends MicrosoftTeamsAppIdentifier {\n  /**\n   * The identifier kind.\n   */\n  kind: \"microsoftTeamsApp\";\n}\n\n/**\n * IdentifierKind for UnknownIdentifier.\n */\nexport interface UnknownIdentifierKind extends UnknownIdentifier {\n  /**\n   * The identifier kind.\n   */\n  kind: \"unknown\";\n}\n\n/**\n * Returns the CommunicationIdentifierKind for a given CommunicationIdentifier. Returns undefined if the kind couldn't be inferred.\n *\n * @param identifier - The identifier whose kind is to be inferred.\n */\nexport const getIdentifierKind = (\n  identifier: CommunicationIdentifier,\n): CommunicationIdentifierKind => {\n  if (isCommunicationUserIdentifier(identifier)) {\n    return { ...identifier, kind: \"communicationUser\" };\n  }\n  if (isPhoneNumberIdentifier(identifier)) {\n    return { ...identifier, kind: \"phoneNumber\" };\n  }\n  if (isMicrosoftTeamsUserIdentifier(identifier)) {\n    return { ...identifier, kind: \"microsoftTeamsUser\" };\n  }\n  if (isMicrosoftTeamsAppIdentifier(identifier)) {\n    return { ...identifier, kind: \"microsoftTeamsApp\" };\n  }\n  return { ...identifier, kind: \"unknown\" };\n};\n\n/**\n * Returns the rawId for a given CommunicationIdentifier. You can use the rawId for encoding the identifier and then use it as a key in a database.\n *\n * @param identifier - The identifier to be translated to its rawId.\n */\nexport const getIdentifierRawId = (identifier: CommunicationIdentifier): string => {\n  const identifierKind = getIdentifierKind(identifier);\n  switch (identifierKind.kind) {\n    case \"communicationUser\":\n      return identifierKind.communicationUserId;\n    case \"microsoftTeamsUser\": {\n      const { microsoftTeamsUserId, rawId, cloud, isAnonymous } = identifierKind;\n      if (rawId) return rawId;\n      if (isAnonymous) return `8:teamsvisitor:${microsoftTeamsUserId}`;\n      switch (cloud) {\n        case \"dod\":\n          return `8:dod:${microsoftTeamsUserId}`;\n        case \"gcch\":\n          return `8:gcch:${microsoftTeamsUserId}`;\n        case \"public\":\n          return `8:orgid:${microsoftTeamsUserId}`;\n      }\n      return `8:orgid:${microsoftTeamsUserId}`;\n    }\n    case \"microsoftTeamsApp\": {\n      const { teamsAppId, rawId, cloud } = identifierKind;\n      if (rawId) return rawId;\n      switch (cloud) {\n        case \"dod\":\n          return `28:dod:${teamsAppId}`;\n        case \"gcch\":\n          return `28:gcch:${teamsAppId}`;\n      }\n      return `28:orgid:${teamsAppId}`;\n    }\n    case \"phoneNumber\": {\n      const { phoneNumber, rawId } = identifierKind;\n      if (rawId) return rawId;\n      return `4:${phoneNumber}`;\n    }\n    case \"unknown\": {\n      return identifierKind.id;\n    }\n  }\n};\n\nconst buildMicrosoftTeamsAppIdentifier = (\n  teamsAppId: string,\n  cloud: \"public\" | \"dod\" | \"gcch\",\n): CommunicationIdentifierKind => {\n  return {\n    kind: \"microsoftTeamsApp\",\n    teamsAppId: teamsAppId,\n    cloud: cloud,\n  };\n};\n\nconst buildMicrosoftTeamsUserIdentifier = (\n  id: string,\n  cloud: \"public\" | \"dod\" | \"gcch\",\n  isAnonymous: boolean,\n): CommunicationIdentifierKind => {\n  return {\n    kind: \"microsoftTeamsUser\",\n    microsoftTeamsUserId: id,\n    isAnonymous: isAnonymous,\n    cloud: cloud,\n  };\n};\n\n/**\n * Creates a CommunicationIdentifierKind from a given rawId. When storing rawIds use this function to restore the identifier that was encoded in the rawId.\n *\n * @param rawId - The rawId to be translated to its identifier representation.\n */\nexport const createIdentifierFromRawId = (rawId: string): CommunicationIdentifierKind => {\n  if (rawId.startsWith(\"4:\")) {\n    return { kind: \"phoneNumber\", phoneNumber: `${rawId.substring(\"4:\".length)}` };\n  }\n\n  const segments = rawId.split(\":\");\n  if (segments.length !== 3) {\n    return { kind: \"unknown\", id: rawId };\n  }\n\n  const prefix = `${segments[0]}:${segments[1]}:`;\n  const suffix = segments[2];\n\n  switch (prefix) {\n    case \"8:teamsvisitor:\":\n      return { kind: \"microsoftTeamsUser\", microsoftTeamsUserId: suffix, isAnonymous: true };\n    case \"8:orgid:\":\n      return buildMicrosoftTeamsUserIdentifier(suffix, \"public\", false);\n    case \"8:dod:\":\n      return buildMicrosoftTeamsUserIdentifier(suffix, \"dod\", false);\n    case \"8:gcch:\":\n      return buildMicrosoftTeamsUserIdentifier(suffix, \"gcch\", false);\n    case \"8:acs:\":\n    case \"8:spool:\":\n    case \"8:dod-acs:\":\n    case \"8:gcch-acs:\":\n      return { kind: \"communicationUser\", communicationUserId: rawId };\n    case \"28:orgid:\":\n      return buildMicrosoftTeamsAppIdentifier(suffix, \"public\");\n    case \"28:gcch:\":\n      return buildMicrosoftTeamsAppIdentifier(suffix, \"gcch\");\n    case \"28:dod:\":\n      return buildMicrosoftTeamsAppIdentifier(suffix, \"dod\");\n  }\n  return { kind: \"unknown\", id: rawId };\n};\n", "// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport {\n  CommunicationIdentifier,\n  CommunicationIdentifierKind,\n  getIdentifierKind,\n  getIdentifierRawId,\n} from \"./identifierModels\";\n\n/**\n * @hidden\n * Identifies a participant in Azure Communication services. A participant is, for example, a phone number or an Azure communication user. This model must be interpreted as a union: Apart from rawId, at most one further property may be set.\n */\nexport interface SerializedCommunicationIdentifier {\n  /**\n   * Kind of the identifier, optional.\n   */\n  kind?: string;\n  /**\n   * Raw Id of the identifier. Optional in requests, required in responses.\n   */\n  rawId?: string;\n  /**\n   * The communication user.\n   */\n  communicationUser?: SerializedCommunicationUserIdentifier;\n  /**\n   * The phone number.\n   */\n  phoneNumber?: SerializedPhoneNumberIdentifier;\n  /**\n   * The Microsoft Teams user.\n   */\n  microsoftTeamsUser?: SerializedMicrosoftTeamsUserIdentifier;\n  /**\n   * The Microsoft Teams App.\n   */\n  microsoftTeamsApp?: SerializedMicrosoftTeamsAppIdentifier;\n}\n\n/**\n * @hidden\n * A user that got created with an Azure Communication Services resource.\n */\nexport interface SerializedCommunicationUserIdentifier {\n  /**\n   * The Id of the communication user.\n   */\n  id: string;\n}\n\n/**\n * @hidden\n * A phone number.\n */\nexport interface SerializedPhoneNumberIdentifier {\n  /**\n   * The phone number in E.164 format.\n   */\n  value: string;\n}\n\n/**\n * @hidden\n * A Microsoft Teams user.\n */\nexport interface SerializedMicrosoftTeamsUserIdentifier {\n  /**\n   * The Id of the Microsoft Teams user. If not anonymous, this is the AAD object Id of the user.\n   */\n  userId: string;\n  /**\n   * True if the Microsoft Teams user is anonymous. By default false if missing.\n   */\n  isAnonymous?: boolean;\n  /**\n   * The cloud that the Microsoft Teams user belongs to. By default 'public' if missing.\n   */\n  cloud?: SerializedCommunicationCloudEnvironment;\n}\n\n/**\n * @hidden\n * A Microsoft Teams App.\n */\nexport interface SerializedMicrosoftTeamsAppIdentifier {\n  /**\n   * Id of the Microsoft Teams App.\n   */\n  appId: string;\n\n  /**\n   * The cloud that the Microsoft Teams App belongs to. By default 'public' if missing.\n   */\n  cloud?: SerializedCommunicationCloudEnvironment;\n}\n\n/**\n * @hidden\n * Defines values for CommunicationCloudEnvironmentModel.\n */\nexport type SerializedCommunicationCloudEnvironment = \"public\" | \"dod\" | \"gcch\";\n\nconst assertNotNullOrUndefined = <\n  T extends Record<string, unknown>,\n  P extends keyof T,\n  Q extends string & keyof T[P],\n>(\n  obj: T,\n  prop: Q,\n): Required<Required<T>[P]>[Q] => {\n  const subObjName = Object.keys(obj)[0];\n  const subObj = (obj as any)[subObjName];\n  if (prop in subObj) {\n    return subObj[prop];\n  }\n  throw new Error(`Property ${prop} is required for identifier of type ${subObjName}.`);\n};\n\nconst assertMaximumOneNestedModel = (identifier: SerializedCommunicationIdentifier): void => {\n  const presentProperties: string[] = [];\n  if (identifier.communicationUser !== undefined) {\n    presentProperties.push(\"communicationUser\");\n  }\n  if (identifier.microsoftTeamsUser !== undefined) {\n    presentProperties.push(\"microsoftTeamsUser\");\n  }\n  if (identifier.microsoftTeamsApp !== undefined) {\n    presentProperties.push(\"microsoftTeamsApp\");\n  }\n  if (identifier.phoneNumber !== undefined) {\n    presentProperties.push(\"phoneNumber\");\n  }\n  if (presentProperties.length > 1) {\n    throw new Error(\n      `Only one of the properties in ${JSON.stringify(presentProperties)} should be present.`,\n    );\n  }\n};\n\n/**\n * @hidden\n * Translates a CommunicationIdentifier to its serialized format for sending a request.\n * @param identifier - The CommunicationIdentifier to be serialized.\n */\nexport const serializeCommunicationIdentifier = (\n  identifier: CommunicationIdentifier,\n): SerializedCommunicationIdentifier => {\n  const identifierKind = getIdentifierKind(identifier);\n  switch (identifierKind.kind) {\n    case \"communicationUser\":\n      return {\n        rawId: getIdentifierRawId(identifierKind),\n        communicationUser: { id: identifierKind.communicationUserId },\n      };\n    case \"phoneNumber\":\n      return {\n        rawId: identifierKind.rawId ?? getIdentifierRawId(identifierKind),\n        phoneNumber: {\n          value: identifierKind.phoneNumber,\n        },\n      };\n    case \"microsoftTeamsUser\":\n      return {\n        rawId: identifierKind.rawId ?? getIdentifierRawId(identifierKind),\n        microsoftTeamsUser: {\n          userId: identifierKind.microsoftTeamsUserId,\n          isAnonymous: identifierKind.isAnonymous ?? false,\n          cloud: identifierKind.cloud ?? \"public\",\n        },\n      };\n    case \"microsoftTeamsApp\":\n      return {\n        rawId: identifierKind.rawId ?? getIdentifierRawId(identifierKind),\n        microsoftTeamsApp: {\n          appId: identifierKind.teamsAppId,\n          cloud: identifierKind.cloud ?? \"public\",\n        },\n      };\n    case \"unknown\":\n      return { rawId: identifierKind.id };\n    default:\n      throw new Error(`Can't serialize an identifier with kind ${(identifierKind as any).kind}`);\n  }\n};\n\nconst getKind = (serializedIdentifier: SerializedCommunicationIdentifier): string => {\n  if (serializedIdentifier.communicationUser) {\n    return \"communicationUser\";\n  }\n\n  if (serializedIdentifier.phoneNumber) {\n    return \"phoneNumber\";\n  }\n\n  if (serializedIdentifier.microsoftTeamsUser) {\n    return \"microsoftTeamsUser\";\n  }\n\n  if (serializedIdentifier.microsoftTeamsApp) {\n    return \"microsoftTeamsApp\";\n  }\n\n  return \"unknown\";\n};\n\n/**\n * @hidden\n * Translates the serialized format of a communication identifier to CommunicationIdentifier.\n * @param serializedIdentifier - The SerializedCommunicationIdentifier to be deserialized.\n */\nexport const deserializeCommunicationIdentifier = (\n  serializedIdentifier: SerializedCommunicationIdentifier,\n): CommunicationIdentifierKind => {\n  assertMaximumOneNestedModel(serializedIdentifier);\n\n  const { communicationUser, microsoftTeamsUser, microsoftTeamsApp, phoneNumber } =\n    serializedIdentifier;\n  const kind = serializedIdentifier.kind ?? getKind(serializedIdentifier);\n\n  if (kind === \"communicationUser\" && communicationUser) {\n    return {\n      kind: \"communicationUser\",\n      communicationUserId: assertNotNullOrUndefined({ communicationUser }, \"id\"),\n    };\n  }\n  if (kind === \"phoneNumber\" && phoneNumber) {\n    return {\n      kind: \"phoneNumber\",\n      phoneNumber: assertNotNullOrUndefined({ phoneNumber }, \"value\"),\n      rawId: assertNotNullOrUndefined({ phoneNumber: serializedIdentifier }, \"rawId\"),\n    };\n  }\n  if (kind === \"microsoftTeamsUser\" && microsoftTeamsUser) {\n    return {\n      kind: \"microsoftTeamsUser\",\n      microsoftTeamsUserId: assertNotNullOrUndefined({ microsoftTeamsUser }, \"userId\"),\n      isAnonymous: assertNotNullOrUndefined({ microsoftTeamsUser }, \"isAnonymous\"),\n      cloud: assertNotNullOrUndefined({ microsoftTeamsUser }, \"cloud\"),\n      rawId: assertNotNullOrUndefined({ microsoftTeamsUser: serializedIdentifier }, \"rawId\"),\n    };\n  }\n  if (kind === \"microsoftTeamsApp\" && microsoftTeamsApp) {\n    return {\n      kind: \"microsoftTeamsApp\",\n      teamsAppId: assertNotNullOrUndefined({ microsoftTeamsApp }, \"appId\"),\n      cloud: assertNotNullOrUndefined({ microsoftTeamsApp }, \"cloud\"),\n      rawId: assertNotNullOrUndefined({ microsoftTeamsApp: serializedIdentifier }, \"rawId\"),\n    };\n  }\n  return {\n    kind: \"unknown\",\n    id: assertNotNullOrUndefined({ unknown: serializedIdentifier }, \"rawId\"),\n  };\n};\n"],
  "mappings": "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",
  "names": ["init_browser", "init_browser", "_a", "_b", "_a", "_a", "init_browser", "_a", "init_browser", "logger", "_a", "init_typeGuards", "_a", "_b", "_c", "_d", "init_browser", "init_typeGuards", "rawContent", "init_typeGuards", "_a", "init_browser", "init_typeGuards", "AbortError", "init_AbortError", "init_browser", "init_AbortError", "delay", "AbortError", "StandardAbortMessage", "init_browser", "_a", "_a", "_b", "init_browser", "logger", "_a", "AbortError", "_b", "delay", "init_browser", "_a", "_a", "_a", "init_browser", "_a", "init_browser", "init_browser", "_a", "init_browser", "_a", "init_browser", "isBlob", "buildRequestBody", "_a", "_b", "AbortError", "init_browser", "init_typeGuards", "init_browser", "_a", "_b", "_c", "_d", "_a", "_a", "_a", "_a", "delay", "_a", "logger", "_b", "_c", "_b", "_a", "logger", "browser_exports", "init_browser", "init_browser", "_a", "init_browser", "init_browser", "init_browser", "init_browser", "_a", "isKeyCredential", "_a", "_b", "_c", "_d"]
}
